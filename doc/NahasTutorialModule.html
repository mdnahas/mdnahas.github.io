<h1>An Agda Experiment</h1>

<p>by Michael Nahas</p>

<p>Started 2021-Oct-31</p>

<p>Version 1 2021-Nov-3</p>

<hr />

<p>I wanted to learn Agda.  I decided to do that by
translating all the proofs from my Coq tutorial into
Agda.</p>

<p>This file contains all those proofs.  It is NOT meant
to be an Agda tutorial.  It is just a cheatsheet for
me if I ever want to use Agda in the future.  I'm making
the file available in case anyone who liked my Coq tutorial
wanted to see what Agda was like.  </p>

<p>Agda is different than Coq.  Coq uses tactics to generate the proofs.
The proofs are actually functions, but the code of those functions is
hidden from the user.  Agda writes the proof functions directly.
Instead of tactics, it uses commands in its Emacs mode to help users
write the proofs.  So, you really need to write Agda in a smart editor
like Emacs.</p>

<h2>Location of file and generating</h2>

<p>The latest version of this file is available on my website.
<a href="https://mdnahas.github.io/doc/NahasTutorialModule.html">HTML</a>
<a href="https://mdnahas.github.io/doc/NahasTutorialModule.lagda.md">Agda</a></p>

<p>To generate the HTML file, I used Agda's literate programming
feature with Markdown.  I generate it by running:</p>

<p><code>agda -i /usr/share/agda-stdlib/ --html --html-highlight=code NahasTutorialModule.lagda.md</code></p>

<p><code>markdown html/NahasTutorialModule.md &gt; NahasTutorialModule.html</code></p>

<h2>Resources</h2>

<p><a href="https://agda.readthedocs.io/en/latest/tools/emacs-mode.html">Agda Emacs Mode commands</a></p>

<p><a href="https://people.inf.elte.hu/divip/AgdaTutorial/Symbols.html">List of operators in Agda</a></p>

<p>In Agda's Emacs mode, you can middle-click on a goal and you will get
a context menu with the possible commands.  This is very useful when
you're not sure what to do next.</p>

<p>In Agda's Emacs mode, if you want to figure out how to type a
character, you can do "M-x describe-char" or "C-u C-x =".  That
command generates a lot of output, but one line will say something
like "to input: type "\union" or "\u+" or "\uplus" with Agda input
method"</p>

<pre class="Agda">
<a id="1989" class="Comment">{- Comments -}</a>
<a id="2004" class="Comment">{- Comments start with a &#39;{&#39; followed by a &#39;-&#39;.  
 and end with a &#39;-&#39; followed by a &#39;}&#39;.
-}</a>

<a id="2097" class="Comment">-- You can also do single-line comments, where the line starts with two &#39;-&#39;s.</a>

</pre>

<h2>Modules</h2>

<p>Agda files must start with a module declaration.  The name of the
module must match the name of the file.</p>

<pre class="Agda">
<a id="2309" class="Keyword">module</a> <a id="2316" href="NahasTutorialModule.html" class="Module">NahasTutorialModule</a> <a id="2336" class="Keyword">where</a>

</pre>

<h2>Basics</h2>

<p>This is how to write an inductive type.  NOTE: the spaces around the ':' are important!</p>

<pre class="Agda">
<a id="2457" class="Keyword">data</a> <a id="Bool"></a><a id="2462" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a> <a id="2467" class="Symbol">:</a> <a id="2469" class="PrimitiveType">Set</a> <a id="2473" class="Keyword">where</a>
  <a id="Bool.true"></a><a id="2481" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="2486" class="Symbol">:</a> <a id="2488" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a>
  <a id="Bool.false"></a><a id="2495" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="2501" class="Symbol">:</a> <a id="2503" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a>

</pre>

<p>This is a function.  Function implementation is done by case matching. The single equal sign '=' is definitional.</p>

<pre class="Agda">
<a id="not"></a><a id="2638" href="NahasTutorialModule.html#2638" class="Function">not</a> <a id="2642" class="Symbol">:</a> <a id="2644" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a> <a id="2649" class="Symbol">→</a> <a id="2651" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a>
<a id="2656" href="NahasTutorialModule.html#2638" class="Function">not</a> <a id="2660" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="2665" class="Symbol">=</a> <a id="2667" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a>
<a id="2673" href="NahasTutorialModule.html#2638" class="Function">not</a> <a id="2677" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="2683" class="Symbol">=</a> <a id="2685" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a>

</pre>

<p>Adga allows unicode.  The right arrow above could be typed "->"
or it can be entered using the LaTeX-like sequence
"\to" which will be automagically converted to the
right arrow you see above.  </p>

<p>Enter "→" with "\to".</p>

<p>In Emacs, use "C-c C-l" to "load" the file.  This will have the Agda
compiler parse the file and show you all the errors, etc..</p>

<p>To test a definition of a function, you can use "C-c C-n".
You can then type in a value like "not true" and it will
be evaluated to "false".</p>

<pre class="Agda">
<a id="¬¬"></a><a id="3196" href="NahasTutorialModule.html#3196" class="Function">¬¬</a> <a id="3199" class="Symbol">:</a> <a id="3201" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a> <a id="3206" class="Symbol">→</a> <a id="3208" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a>
<a id="3213" href="NahasTutorialModule.html#3196" class="Function">¬¬</a> <a id="3216" href="NahasTutorialModule.html#3216" class="Bound">b</a> <a id="3218" class="Symbol">=</a> <a id="3220" href="NahasTutorialModule.html#2638" class="Function">not</a> <a id="3224" class="Symbol">(</a><a id="3225" href="NahasTutorialModule.html#2638" class="Function">not</a> <a id="3229" href="NahasTutorialModule.html#3216" class="Bound">b</a><a id="3230" class="Symbol">)</a>

</pre>

<p>Enter '¬' with "\neg".</p>

<p>Note that "¬¬" is a single operator, even though it is 2 characters.</p>

<p>If you enter
<br><code>¬¬ b = ?</code><br>
and do "C-c C-l", you get:
<br><code>¬¬ b = { }0</code><br></p>

<p>The <code>{ }0</code> is a "hole" and, in this case, hole number 0.
(You can have multiple holes.)</p>

<p>The idea is that the hole is something to fill in later.
The type checker can identify the type of the hole and
help you fill it in.
Another window will open up that tells you the type of
the hole: "<code>?0 : Bool</code>", meaning hole number 0 has type
"Bool".</p>

<p>So if you enter:
<br><code>¬¬ b = {not ? }0</code><br>
It means that you want to replace the hole by "not ?" 
And when do "C-c C-l", then you get:
<br><code>¬¬ b = not { }1</code><br>
That is, it has accepted the "not" and created a new
hole, which is now hole number 1.</p>

<p>Next:
<br><code>¬¬ b = not {not ?}1</code><br>
becomes 
<br><code>¬¬ b = not (not { }2)</code><br>
and then
<br><code>¬¬ b = not (not {b }2)</code><br>
does nothing with "C-c C-l".</p>

<p>This is because "b" has the appropriate type.  To get rid of
the hole, you need to use "C-c spacebar".
Then you get:
<br><code>¬¬ b = not (not b)</code><br></p>

<p>Coq: "C-c spacebar" is like "exact".</p>

<h2>Proofs</h2>

<p>I'm trying to learn how to prove in Agda, so let's try a proof.
A proof is a function</p>

<pre class="Agda">
<a id="myFirstProof"></a><a id="4448" href="NahasTutorialModule.html#4448" class="Function">myFirstProof</a> <a id="4461" class="Symbol">:</a> <a id="4463" class="Symbol">(</a><a id="4464" href="NahasTutorialModule.html#4464" class="Bound">A</a> <a id="4466" class="Symbol">:</a> <a id="4468" class="PrimitiveType">Set</a><a id="4471" class="Symbol">)</a> <a id="4473" class="Symbol">→</a> <a id="4475" href="NahasTutorialModule.html#4464" class="Bound">A</a> <a id="4477" class="Symbol">→</a> <a id="4479" href="NahasTutorialModule.html#4464" class="Bound">A</a>
<a id="4481" href="NahasTutorialModule.html#4448" class="Function">myFirstProof</a> <a id="4494" href="NahasTutorialModule.html#4494" class="Bound">A</a> <a id="4496" href="NahasTutorialModule.html#4496" class="Bound">proofofA</a> <a id="4505" class="Symbol">=</a> <a id="4507" href="NahasTutorialModule.html#4496" class="Bound">proofofA</a>

</pre>

<p>A proof is a function, so it looks like "not" that was written above.
Here, the proof takes a proposition "A" and a proof of that
proposition, and returns the proof of the proposition.</p>

<p>If you enter
<br><code>myfirstproof A proofofA = ?</code><br>
And do "C-c C-l"
you'll get a hole.
<br><code>myfirstproof A proofofA = {!!}0</code><br>
and, with the cursor in the hole, "C-c C-e" will show the context
("e" is meant to mean "environment").
Since the hole is type "A" and you have "proofofA" in the environment,
typing "proofofA" and "C-c C-spacebar" will solve the proof.</p>

<p>If instead you started with
<br><code>myfirstproofagain = ?</code><br>
You can do "C-c C-c enter" and Agda will automatically change it to
<br><code>myfirstproofagain A x = ?</code><br>
And then you can follow the proof as above.</p>

<p>Coq: If you want "intros", do "C-c C-c enter"</p>

<pre class="Agda">
<a id="backwardsSmall"></a><a id="5340" href="NahasTutorialModule.html#5340" class="Function">backwardsSmall</a> <a id="5355" class="Symbol">:</a> <a id="5357" class="Symbol">(</a><a id="5358" href="NahasTutorialModule.html#5358" class="Bound">A</a> <a id="5360" href="NahasTutorialModule.html#5360" class="Bound">B</a> <a id="5362" class="Symbol">:</a> <a id="5364" class="PrimitiveType">Set</a><a id="5367" class="Symbol">)</a> <a id="5369" class="Symbol">→</a> <a id="5371" href="NahasTutorialModule.html#5358" class="Bound">A</a> <a id="5373" class="Symbol">→</a> <a id="5375" class="Symbol">(</a><a id="5376" href="NahasTutorialModule.html#5358" class="Bound">A</a> <a id="5378" class="Symbol">→</a> <a id="5380" href="NahasTutorialModule.html#5360" class="Bound">B</a><a id="5381" class="Symbol">)</a> <a id="5383" class="Symbol">→</a> <a id="5385" href="NahasTutorialModule.html#5360" class="Bound">B</a>
<a id="5387" href="NahasTutorialModule.html#5340" class="Function">backwardsSmall</a> <a id="5402" href="NahasTutorialModule.html#5402" class="Bound">A</a> <a id="5404" href="NahasTutorialModule.html#5404" class="Bound">B</a> <a id="5406" href="NahasTutorialModule.html#5406" class="Bound">a</a> <a id="5408" href="NahasTutorialModule.html#5408" class="Bound">atob</a> <a id="5413" class="Symbol">=</a> <a id="5415" href="NahasTutorialModule.html#5408" class="Bound">atob</a> <a id="5420" href="NahasTutorialModule.html#5406" class="Bound">a</a>

</pre>

<p>To solve this, I did "C-c C-e" to look at the context ("environment")
Saw I had a function "<code>atob : A → B</code>"
Typed "atob" in the hole and hit "C-c C-r".  This is the "refine"
command and it applies a function and creates hole for every argument
to the function.</p>

<p>Coq: "refine" or "apply" is enter the name of the function in the hole
and enter "C-c C-r".</p>

<p>Proving backwards tries to keep making the goal simpler.  We can also
prove going forwards, where we keep adding terms to the context
("environment") until we build up a term with the same type as the goal.</p>

<pre class="Agda">
<a id="forwardSmall"></a><a id="6000" href="NahasTutorialModule.html#6000" class="Function">forwardSmall</a> <a id="6013" class="Symbol">:</a> <a id="6015" class="Symbol">(</a><a id="6016" href="NahasTutorialModule.html#6016" class="Bound">A</a> <a id="6018" href="NahasTutorialModule.html#6018" class="Bound">B</a> <a id="6020" class="Symbol">:</a> <a id="6022" class="PrimitiveType">Set</a><a id="6025" class="Symbol">)</a> <a id="6027" class="Symbol">→</a> <a id="6029" href="NahasTutorialModule.html#6016" class="Bound">A</a> <a id="6031" class="Symbol">→</a> <a id="6033" class="Symbol">(</a><a id="6034" href="NahasTutorialModule.html#6016" class="Bound">A</a> <a id="6036" class="Symbol">→</a> <a id="6038" href="NahasTutorialModule.html#6018" class="Bound">B</a><a id="6039" class="Symbol">)</a> <a id="6041" class="Symbol">→</a> <a id="6043" href="NahasTutorialModule.html#6018" class="Bound">B</a>
<a id="6045" href="NahasTutorialModule.html#6000" class="Function">forwardSmall</a> <a id="6058" href="NahasTutorialModule.html#6058" class="Bound">A</a> <a id="6060" href="NahasTutorialModule.html#6060" class="Bound">B</a> <a id="6062" href="NahasTutorialModule.html#6062" class="Bound">a</a> <a id="6064" href="NahasTutorialModule.html#6064" class="Bound">atob</a> <a id="6069" class="Symbol">=</a> <a id="6071" class="Keyword">let</a> <a id="6075" href="NahasTutorialModule.html#6075" class="Bound">b</a> <a id="6077" class="Symbol">=</a> <a id="6079" href="NahasTutorialModule.html#6064" class="Bound">atob</a> <a id="6084" href="NahasTutorialModule.html#6062" class="Bound">a</a> <a id="6086" class="Keyword">in</a> <a id="6089" href="NahasTutorialModule.html#6075" class="Bound">b</a>

</pre>

<p>To prove in the forward direction, I filled the hole with
"<code>let b = atob a in ?</code>".
After hitting "C-c C-spacebar", the context now had a term "b : B"
and since that matched the goal, I could enter "b" and then
type "C-c C-spacebar" to finish the proof.</p>

<pre class="Agda">
<a id="backwardsLarge"></a><a id="6360" href="NahasTutorialModule.html#6360" class="Function">backwardsLarge</a> <a id="6375" class="Symbol">:</a> <a id="6377" class="Symbol">(</a><a id="6378" href="NahasTutorialModule.html#6378" class="Bound">A</a> <a id="6380" href="NahasTutorialModule.html#6380" class="Bound">B</a> <a id="6382" href="NahasTutorialModule.html#6382" class="Bound">C</a> <a id="6384" class="Symbol">:</a> <a id="6386" class="PrimitiveType">Set</a><a id="6389" class="Symbol">)</a> <a id="6391" class="Symbol">→</a> <a id="6393" href="NahasTutorialModule.html#6378" class="Bound">A</a> <a id="6395" class="Symbol">→</a> <a id="6397" class="Symbol">(</a><a id="6398" href="NahasTutorialModule.html#6378" class="Bound">A</a> <a id="6400" class="Symbol">→</a> <a id="6402" href="NahasTutorialModule.html#6380" class="Bound">B</a><a id="6403" class="Symbol">)</a> <a id="6405" class="Symbol">→</a> <a id="6407" class="Symbol">(</a><a id="6408" href="NahasTutorialModule.html#6380" class="Bound">B</a> <a id="6410" class="Symbol">→</a> <a id="6412" href="NahasTutorialModule.html#6382" class="Bound">C</a><a id="6413" class="Symbol">)</a> <a id="6415" class="Symbol">→</a> <a id="6417" href="NahasTutorialModule.html#6382" class="Bound">C</a>
<a id="6419" href="NahasTutorialModule.html#6360" class="Function">backwardsLarge</a> <a id="6434" href="NahasTutorialModule.html#6434" class="Bound">A</a> <a id="6436" href="NahasTutorialModule.html#6436" class="Bound">B</a> <a id="6438" href="NahasTutorialModule.html#6438" class="Bound">C</a> <a id="6440" href="NahasTutorialModule.html#6440" class="Bound">a</a> <a id="6442" href="NahasTutorialModule.html#6442" class="Bound">atob</a> <a id="6447" href="NahasTutorialModule.html#6447" class="Bound">btoc</a> <a id="6452" class="Symbol">=</a> <a id="6454" href="NahasTutorialModule.html#6447" class="Bound">btoc</a> <a id="6459" class="Symbol">(</a><a id="6460" href="NahasTutorialModule.html#6442" class="Bound">atob</a> <a id="6465" href="NahasTutorialModule.html#6440" class="Bound">a</a><a id="6466" class="Symbol">)</a>

<a id="forewardsLarge"></a><a id="6469" href="NahasTutorialModule.html#6469" class="Function">forewardsLarge</a> <a id="6484" class="Symbol">:</a> <a id="6486" class="Symbol">(</a><a id="6487" href="NahasTutorialModule.html#6487" class="Bound">A</a> <a id="6489" href="NahasTutorialModule.html#6489" class="Bound">B</a> <a id="6491" href="NahasTutorialModule.html#6491" class="Bound">C</a> <a id="6493" class="Symbol">:</a> <a id="6495" class="PrimitiveType">Set</a><a id="6498" class="Symbol">)</a> <a id="6500" class="Symbol">→</a> <a id="6502" href="NahasTutorialModule.html#6487" class="Bound">A</a> <a id="6504" class="Symbol">→</a> <a id="6506" class="Symbol">(</a><a id="6507" href="NahasTutorialModule.html#6487" class="Bound">A</a> <a id="6509" class="Symbol">→</a> <a id="6511" href="NahasTutorialModule.html#6489" class="Bound">B</a><a id="6512" class="Symbol">)</a> <a id="6514" class="Symbol">→</a> <a id="6516" class="Symbol">(</a><a id="6517" href="NahasTutorialModule.html#6489" class="Bound">B</a> <a id="6519" class="Symbol">→</a> <a id="6521" href="NahasTutorialModule.html#6491" class="Bound">C</a><a id="6522" class="Symbol">)</a> <a id="6524" class="Symbol">→</a> <a id="6526" href="NahasTutorialModule.html#6491" class="Bound">C</a>
<a id="6528" href="NahasTutorialModule.html#6469" class="Function">forewardsLarge</a> <a id="6543" href="NahasTutorialModule.html#6543" class="Bound">A</a> <a id="6545" href="NahasTutorialModule.html#6545" class="Bound">B</a> <a id="6547" href="NahasTutorialModule.html#6547" class="Bound">C</a> <a id="6549" href="NahasTutorialModule.html#6549" class="Bound">a</a> <a id="6551" href="NahasTutorialModule.html#6551" class="Bound">atob</a> <a id="6556" href="NahasTutorialModule.html#6556" class="Bound">btoc</a> <a id="6561" class="Symbol">=</a> <a id="6563" class="Keyword">let</a> <a id="6567" href="NahasTutorialModule.html#6567" class="Bound">b</a> <a id="6569" class="Symbol">=</a> <a id="6571" href="NahasTutorialModule.html#6551" class="Bound">atob</a> <a id="6576" href="NahasTutorialModule.html#6549" class="Bound">a</a> <a id="6578" class="Keyword">in</a> <a id="6581" class="Keyword">let</a> <a id="6585" href="NahasTutorialModule.html#6585" class="Bound">c</a> <a id="6587" class="Symbol">=</a> <a id="6589" href="NahasTutorialModule.html#6556" class="Bound">btoc</a> <a id="6594" href="NahasTutorialModule.html#6567" class="Bound">b</a> <a id="6596" class="Keyword">in</a> <a id="6599" href="NahasTutorialModule.html#6585" class="Bound">c</a>


<a id="backwardsHuge"></a><a id="6603" href="NahasTutorialModule.html#6603" class="Function">backwardsHuge</a> <a id="6617" class="Symbol">:</a> <a id="6619" class="Symbol">(</a><a id="6620" href="NahasTutorialModule.html#6620" class="Bound">A</a> <a id="6622" href="NahasTutorialModule.html#6622" class="Bound">B</a> <a id="6624" href="NahasTutorialModule.html#6624" class="Bound">C</a> <a id="6626" class="Symbol">:</a> <a id="6628" class="PrimitiveType">Set</a><a id="6631" class="Symbol">)</a> <a id="6633" class="Symbol">→</a> <a id="6635" href="NahasTutorialModule.html#6620" class="Bound">A</a> <a id="6637" class="Symbol">→</a> <a id="6639" class="Symbol">(</a><a id="6640" href="NahasTutorialModule.html#6620" class="Bound">A</a> <a id="6642" class="Symbol">→</a> <a id="6644" href="NahasTutorialModule.html#6622" class="Bound">B</a><a id="6645" class="Symbol">)</a> <a id="6647" class="Symbol">→</a> <a id="6649" class="Symbol">(</a><a id="6650" href="NahasTutorialModule.html#6620" class="Bound">A</a> <a id="6652" class="Symbol">→</a> <a id="6654" href="NahasTutorialModule.html#6622" class="Bound">B</a> <a id="6656" class="Symbol">→</a> <a id="6658" href="NahasTutorialModule.html#6624" class="Bound">C</a><a id="6659" class="Symbol">)</a> <a id="6661" class="Symbol">→</a> <a id="6663" href="NahasTutorialModule.html#6624" class="Bound">C</a>
<a id="6665" href="NahasTutorialModule.html#6603" class="Function">backwardsHuge</a> <a id="6679" href="NahasTutorialModule.html#6679" class="Bound">A</a> <a id="6681" href="NahasTutorialModule.html#6681" class="Bound">B</a> <a id="6683" href="NahasTutorialModule.html#6683" class="Bound">C</a> <a id="6685" href="NahasTutorialModule.html#6685" class="Bound">a</a> <a id="6687" href="NahasTutorialModule.html#6687" class="Bound">atob</a> <a id="6692" href="NahasTutorialModule.html#6692" class="Bound">aandbtoc</a> <a id="6701" class="Symbol">=</a> <a id="6703" href="NahasTutorialModule.html#6692" class="Bound">aandbtoc</a> <a id="6712" href="NahasTutorialModule.html#6685" class="Bound">a</a> <a id="6714" class="Symbol">(</a><a id="6715" href="NahasTutorialModule.html#6687" class="Bound">atob</a> <a id="6720" href="NahasTutorialModule.html#6685" class="Bound">a</a><a id="6721" class="Symbol">)</a>

</pre>

<p>The only difference here is that when you enter "aandbtoc"
into the initial hole and hit "C-c C-r", there are 2 holes
created. 
<br><code>backwardshuge A B C a atob aandbtoc = aandbtoc { }2 { }3</code><br>
The other window shows the type of each.  By looking at the
context, we can find variables or functions to supply
the type of each.</p>

<h2>Unit and Empty types</h2>

<p>The Unit type has only one constructor.  </p>

<p>The Empty type has none.</p>

<p>Using the BHK interpretation, we can use the Unit type in place
of "true" and "Empty" in place of "false" in many logic statements.
We need to replace "implication" with the function type →.</p>

<pre class="Agda">
<a id="7354" class="Keyword">record</a> <a id="⊤"></a><a id="7361" href="NahasTutorialModule.html#7361" class="Record">⊤</a> <a id="7363" class="Symbol">:</a> <a id="7365" class="PrimitiveType">Set</a> <a id="7369" class="Keyword">where</a>
  <a id="7377" class="Keyword">constructor</a> <a id="⊤.tt"></a><a id="7389" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>

</pre>

<p>Enter '⊤' with "\top".</p>

<p>A "record" is the same as "data", but with only 1 constructor.
The constructor is "tt".</p>

<p>Later on, instead of using "tt", you can also use "record {}".  That
can be used for any record, with the record's parameters inside the
curly braces.  Agda can figure out the correct constructor from the
type of the hole.</p>

<p>Agda does have "Prop", which is similar to "Set" but is
"proof irrelevant".  But using it requires using a command-line
argument with Agda and I wasn't sure how to do that in Agda's
Emacs mode.</p>

<p>Agda's Sets have a index associated with them.  It allows a Set in a
higher universe to contain Sets in the lower universe.  I found the
indices added a lot of confusion to types and didn't add much, so for
this file I've deleted them.  </p>

<pre class="Agda">

<a id="8179" class="Keyword">data</a> <a id="⊥"></a><a id="8184" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a> <a id="8186" class="Symbol">:</a> <a id="8188" class="PrimitiveType">Set</a> <a id="8192" class="Keyword">where</a>

</pre>

<p>Enter '⊥' with "\bot".</p>

<p>This type has no constructors.</p>

<pre class="Agda">
<a id="trueCanBeProven"></a><a id="8269" href="NahasTutorialModule.html#8269" class="Function">trueCanBeProven</a> <a id="8285" class="Symbol">:</a> <a id="8287" href="NahasTutorialModule.html#7361" class="Record">⊤</a>
<a id="8289" href="NahasTutorialModule.html#8269" class="Function">trueCanBeProven</a> <a id="8305" class="Symbol">=</a> <a id="8307" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>

</pre>

<p>I'm actually not sure if there's a Agda Emacs-mode command
that solves this.  I tried "C-c C-c", since there is only 1
constructor (one case), but that didn't work.  It actually
DELETED the line "<code>trueCanBeProven = ?</code>"!</p>

<p>I was able to use the automatic solver, "C-c C-a".</p>

<p>Definition of "not" for types </p>

<pre class="Agda">
<a id="¬_"></a><a id="8630" href="NahasTutorialModule.html#8630" class="Function Operator">¬_</a> <a id="8633" class="Symbol">:</a> <a id="8635" class="PrimitiveType">Set</a> <a id="8639" class="Symbol">→</a> <a id="8641" class="PrimitiveType">Set</a>
<a id="8645" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a> <a id="8647" href="NahasTutorialModule.html#8647" class="Bound">A</a> <a id="8649" class="Symbol">=</a> <a id="8651" href="NahasTutorialModule.html#8647" class="Bound">A</a> <a id="8653" class="Symbol">→</a> <a id="8655" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a>

</pre>

<p>Enter '¬' with "\neg".</p>

<pre class="Agda">
<a id="falseCannotBeProved"></a><a id="8696" href="NahasTutorialModule.html#8696" class="Function">falseCannotBeProved</a> <a id="8716" class="Symbol">:</a> <a id="8718" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a> <a id="8720" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a>
<a id="8722" href="NahasTutorialModule.html#8696" class="Function">falseCannotBeProved</a> <a id="8742" href="NahasTutorialModule.html#8742" class="Bound">proofoffalse</a> <a id="8755" class="Symbol">=</a> <a id="8757" href="NahasTutorialModule.html#8742" class="Bound">proofoffalse</a>

</pre>

<p>This is pretty much a normal proof now.
"C-c C-c enter" will add the argument that I renamed "<code>proofoffalse</code>".
then that is an exact match for the goal.</p>

<p>In Agda, it is harder to see that "¬" is actually a function
and takes an argument.  But the proof is easy after that.</p>

<pre class="Agda">
<a id="falseCannotBeProvedAgain"></a><a id="9059" href="NahasTutorialModule.html#9059" class="Function">falseCannotBeProvedAgain</a> <a id="9084" class="Symbol">:</a> <a id="9086" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a> <a id="9088" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a>
<a id="9090" href="NahasTutorialModule.html#9059" class="Function">falseCannotBeProvedAgain</a> <a id="9115" class="Symbol">()</a>

</pre>

<p>This is the other proof, where I do cases on the argument "proofoffalse".
That is accomplished by entering "proofoffalse" in the hole and then
entering "C-c C-c".
It results in "falseCannotBeProvedAgain ()" which is Agda's notation
for a definition where there are no cases because the particular argument
has no possible instances.</p>

<pre class="Agda">
<a id="trueImpliesTrue"></a><a id="9467" href="NahasTutorialModule.html#9467" class="Function">trueImpliesTrue</a> <a id="9483" class="Symbol">:</a> <a id="9485" href="NahasTutorialModule.html#7361" class="Record">⊤</a> <a id="9487" class="Symbol">→</a> <a id="9489" href="NahasTutorialModule.html#7361" class="Record">⊤</a>
<a id="9491" href="NahasTutorialModule.html#9467" class="Function">trueImpliesTrue</a> <a id="9507" href="NahasTutorialModule.html#9507" class="Bound">a</a> <a id="9509" class="Symbol">=</a> <a id="9511" href="NahasTutorialModule.html#9507" class="Bound">a</a>

<a id="falseImpliesTrue"></a><a id="9514" href="NahasTutorialModule.html#9514" class="Function">falseImpliesTrue</a> <a id="9531" class="Symbol">:</a> <a id="9533" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a> <a id="9535" class="Symbol">→</a> <a id="9537" href="NahasTutorialModule.html#7361" class="Record">⊤</a>
<a id="9539" href="NahasTutorialModule.html#9514" class="Function">falseImpliesTrue</a> <a id="9556" href="NahasTutorialModule.html#9556" class="Bound">proofoffalse</a> <a id="9569" class="Symbol">=</a> <a id="9571" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>

<a id="falseImpliesFalse"></a><a id="9575" href="NahasTutorialModule.html#9575" class="Function">falseImpliesFalse</a> <a id="9593" class="Symbol">:</a> <a id="9595" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a> <a id="9597" class="Symbol">→</a> <a id="9599" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a>
<a id="9601" href="NahasTutorialModule.html#9575" class="Function">falseImpliesFalse</a> <a id="9619" class="Symbol">()</a> 

</pre>

<p>Wow!  I was able to write those directly, without any help!</p>

<pre class="Agda">
<a id="trueImpliesFalse"></a><a id="9699" href="NahasTutorialModule.html#9699" class="Function">trueImpliesFalse</a> <a id="9716" class="Symbol">:</a> <a id="9718" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a><a id="9719" class="Symbol">(</a><a id="9720" href="NahasTutorialModule.html#7361" class="Record">⊤</a> <a id="9722" class="Symbol">→</a> <a id="9724" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a><a id="9725" class="Symbol">)</a>
<a id="9727" href="NahasTutorialModule.html#9699" class="Function">trueImpliesFalse</a> <a id="9744" href="NahasTutorialModule.html#9744" class="Bound">truetofalse</a> <a id="9756" class="Symbol">=</a> <a id="9758" href="NahasTutorialModule.html#9744" class="Bound">truetofalse</a> <a id="9770" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>

</pre>

<p>It took a little longer to prove this one, but not too bad.</p>

<pre class="Agda">
<a id="absurdHelper"></a><a id="9849" href="NahasTutorialModule.html#9849" class="Function">absurdHelper</a> <a id="9862" class="Symbol">:</a> <a id="9864" class="Symbol">(</a><a id="9865" href="NahasTutorialModule.html#9865" class="Bound">C</a> <a id="9867" class="Symbol">:</a> <a id="9869" class="PrimitiveType">Set</a><a id="9872" class="Symbol">)</a> <a id="9874" class="Symbol">→</a> <a id="9876" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a> <a id="9878" class="Symbol">→</a> <a id="9880" href="NahasTutorialModule.html#9865" class="Bound">C</a>
<a id="9882" href="NahasTutorialModule.html#9849" class="Function">absurdHelper</a> <a id="9895" href="NahasTutorialModule.html#9895" class="Bound">C</a> <a id="9897" class="Symbol">()</a>

<a id="absurd"></a><a id="9901" href="NahasTutorialModule.html#9901" class="Function">absurd</a> <a id="9908" class="Symbol">:</a> <a id="9910" class="Symbol">(</a><a id="9911" href="NahasTutorialModule.html#9911" class="Bound">A</a> <a id="9913" href="NahasTutorialModule.html#9913" class="Bound">C</a> <a id="9915" class="Symbol">:</a> <a id="9917" class="PrimitiveType">Set</a><a id="9920" class="Symbol">)</a> <a id="9922" class="Symbol">→</a> <a id="9924" href="NahasTutorialModule.html#9911" class="Bound">A</a> <a id="9926" class="Symbol">→</a> <a id="9928" class="Symbol">(</a><a id="9929" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a> <a id="9931" href="NahasTutorialModule.html#9911" class="Bound">A</a><a id="9932" class="Symbol">)</a> <a id="9934" class="Symbol">→</a> <a id="9936" href="NahasTutorialModule.html#9913" class="Bound">C</a>
<a id="9938" href="NahasTutorialModule.html#9901" class="Function">absurd</a> <a id="9945" href="NahasTutorialModule.html#9945" class="Bound">A</a> <a id="9947" href="NahasTutorialModule.html#9947" class="Bound">C</a> <a id="9949" href="NahasTutorialModule.html#9949" class="Bound">proofofA</a> <a id="9958" href="NahasTutorialModule.html#9958" class="Bound">proofthatAcannotbeproven</a> <a id="9983" class="Symbol">=</a> <a id="9985" class="Keyword">let</a> <a id="9989" href="NahasTutorialModule.html#9989" class="Bound">proofoffalse</a> <a id="10002" class="Symbol">=</a> <a id="10004" href="NahasTutorialModule.html#9958" class="Bound">proofthatAcannotbeproven</a> <a id="10029" href="NahasTutorialModule.html#9949" class="Bound">proofofA</a> <a id="10038" class="Keyword">in</a> <a id="10041" href="NahasTutorialModule.html#9849" class="Function">absurdHelper</a> <a id="10054" href="NahasTutorialModule.html#9947" class="Bound">C</a> <a id="10056" href="NahasTutorialModule.html#9989" class="Bound">proofoffalse</a>

<a id="absurdAgain"></a><a id="10070" href="NahasTutorialModule.html#10070" class="Function">absurdAgain</a> <a id="10082" class="Symbol">:</a> <a id="10084" class="Symbol">(</a><a id="10085" href="NahasTutorialModule.html#10085" class="Bound">A</a> <a id="10087" href="NahasTutorialModule.html#10087" class="Bound">C</a> <a id="10089" class="Symbol">:</a> <a id="10091" class="PrimitiveType">Set</a><a id="10094" class="Symbol">)</a> <a id="10096" class="Symbol">→</a> <a id="10098" href="NahasTutorialModule.html#10085" class="Bound">A</a> <a id="10100" class="Symbol">→</a> <a id="10102" class="Symbol">(</a><a id="10103" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a> <a id="10105" href="NahasTutorialModule.html#10085" class="Bound">A</a><a id="10106" class="Symbol">)</a> <a id="10108" class="Symbol">→</a> <a id="10110" href="NahasTutorialModule.html#10087" class="Bound">C</a>
<a id="10112" href="NahasTutorialModule.html#10070" class="Function">absurdAgain</a> <a id="10124" href="NahasTutorialModule.html#10124" class="Bound">A</a> <a id="10126" href="NahasTutorialModule.html#10126" class="Bound">C</a> <a id="10128" href="NahasTutorialModule.html#10128" class="Bound">proofofA</a> <a id="10137" href="NahasTutorialModule.html#10137" class="Bound">proofthatAcannotbeproven</a> <a id="10162" class="Symbol">=</a> <a id="10164" href="NahasTutorialModule.html#9849" class="Function">absurdHelper</a> <a id="10177" href="NahasTutorialModule.html#10126" class="Bound">C</a> <a id="10179" class="Symbol">(</a><a id="10180" href="NahasTutorialModule.html#10137" class="Bound">proofthatAcannotbeproven</a> <a id="10205" href="NahasTutorialModule.html#10128" class="Bound">proofofA</a><a id="10213" class="Symbol">)</a>

</pre>

<p>I found out that you can do local definitions with "where", so the following version hides the definition of the helper function.</p>

<pre class="Agda">
<a id="absurdAgainAgain"></a><a id="10361" href="NahasTutorialModule.html#10361" class="Function">absurdAgainAgain</a> <a id="10378" class="Symbol">:</a> <a id="10380" class="Symbol">(</a><a id="10381" href="NahasTutorialModule.html#10381" class="Bound">A</a> <a id="10383" href="NahasTutorialModule.html#10383" class="Bound">C</a> <a id="10385" class="Symbol">:</a> <a id="10387" class="PrimitiveType">Set</a><a id="10390" class="Symbol">)</a> <a id="10392" class="Symbol">→</a> <a id="10394" href="NahasTutorialModule.html#10381" class="Bound">A</a> <a id="10396" class="Symbol">→</a> <a id="10398" class="Symbol">(</a><a id="10399" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a> <a id="10401" href="NahasTutorialModule.html#10381" class="Bound">A</a><a id="10402" class="Symbol">)</a> <a id="10404" class="Symbol">→</a> <a id="10406" href="NahasTutorialModule.html#10383" class="Bound">C</a>
<a id="10408" href="NahasTutorialModule.html#10361" class="Function">absurdAgainAgain</a> <a id="10425" href="NahasTutorialModule.html#10425" class="Bound">A</a> <a id="10427" href="NahasTutorialModule.html#10427" class="Bound">C</a> <a id="10429" href="NahasTutorialModule.html#10429" class="Bound">proofofA</a> <a id="10438" href="NahasTutorialModule.html#10438" class="Bound">proofthatAcannotbeproven</a> <a id="10463" class="Symbol">=</a> <a id="10465" class="Keyword">let</a> <a id="10469" href="NahasTutorialModule.html#10469" class="Bound">proofoffalse</a> <a id="10482" class="Symbol">=</a> <a id="10484" href="NahasTutorialModule.html#10438" class="Bound">proofthatAcannotbeproven</a> <a id="10509" href="NahasTutorialModule.html#10429" class="Bound">proofofA</a> <a id="10518" class="Keyword">in</a> <a id="10521" href="NahasTutorialModule.html#10560" class="Function">absurdHelper2</a> <a id="10535" href="NahasTutorialModule.html#10427" class="Bound">C</a> <a id="10537" href="NahasTutorialModule.html#10469" class="Bound">proofoffalse</a>
  <a id="10552" class="Keyword">where</a>
  <a id="10560" href="NahasTutorialModule.html#10560" class="Function">absurdHelper2</a> <a id="10574" class="Symbol">:</a> <a id="10576" class="Symbol">(</a><a id="10577" href="NahasTutorialModule.html#10577" class="Bound">C</a> <a id="10579" class="Symbol">:</a> <a id="10581" class="PrimitiveType">Set</a><a id="10584" class="Symbol">)</a> <a id="10586" class="Symbol">→</a> <a id="10588" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a> <a id="10590" class="Symbol">→</a> <a id="10592" href="NahasTutorialModule.html#10577" class="Bound">C</a>
  <a id="10596" href="NahasTutorialModule.html#10560" class="Function">absurdHelper2</a> <a id="10610" href="NahasTutorialModule.html#10610" class="Bound">C</a> <a id="10612" class="Symbol">()</a>

</pre>

<p>And you can use "with" to create a dummy parameter to the function, where they dummy's value is a function of the other parameters.</p>

<pre class="Agda">
<a id="absurdAgainAgainAgainAgain"></a><a id="10764" href="NahasTutorialModule.html#10764" class="Function">absurdAgainAgainAgainAgain</a> <a id="10791" class="Symbol">:</a> <a id="10793" class="Symbol">(</a><a id="10794" href="NahasTutorialModule.html#10794" class="Bound">A</a> <a id="10796" href="NahasTutorialModule.html#10796" class="Bound">C</a> <a id="10798" class="Symbol">:</a> <a id="10800" class="PrimitiveType">Set</a><a id="10803" class="Symbol">)</a> <a id="10805" class="Symbol">→</a> <a id="10807" href="NahasTutorialModule.html#10794" class="Bound">A</a> <a id="10809" class="Symbol">→</a> <a id="10811" class="Symbol">(</a><a id="10812" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a> <a id="10814" href="NahasTutorialModule.html#10794" class="Bound">A</a><a id="10815" class="Symbol">)</a> <a id="10817" class="Symbol">→</a> <a id="10819" href="NahasTutorialModule.html#10796" class="Bound">C</a>
<a id="10821" href="NahasTutorialModule.html#10764" class="Function">absurdAgainAgainAgainAgain</a> <a id="10848" href="NahasTutorialModule.html#10848" class="Bound">A</a> <a id="10850" href="NahasTutorialModule.html#10850" class="Bound">C</a> <a id="10852" href="NahasTutorialModule.html#10852" class="Bound">proofofA</a> <a id="10861" href="NahasTutorialModule.html#10861" class="Bound">proofthatAcannotbeproven</a> <a id="10886" class="Keyword">with</a> <a id="10891" href="NahasTutorialModule.html#10861" class="Bound">proofthatAcannotbeproven</a> <a id="10916" href="NahasTutorialModule.html#10852" class="Bound">proofofA</a>
<a id="10925" href="NahasTutorialModule.html#10764" class="Function">absurdAgainAgainAgainAgain</a> <a id="10952" href="NahasTutorialModule.html#10952" class="Bound">A</a> <a id="10954" href="NahasTutorialModule.html#10954" class="Bound">C</a> <a id="10956" href="NahasTutorialModule.html#10956" class="Bound">proofofA</a> <a id="10965" href="NahasTutorialModule.html#10965" class="Bound">proofthatAcannotbeproven</a> <a id="10990" class="Symbol">|</a> <a id="10992" class="Symbol">()</a>


</pre>

<p>A function mapping true to an inhabited type and false to an empty
type.</p>

<pre class="Agda">
<a id="T"></a><a id="11085" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="11087" class="Symbol">:</a> <a id="11089" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a> <a id="11094" class="Symbol">→</a> <a id="11096" class="PrimitiveType">Set</a>
<a id="11100" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="11102" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a>  <a id="11108" class="Symbol">=</a> <a id="11110" href="NahasTutorialModule.html#7361" class="Record">⊤</a>
<a id="11112" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="11114" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="11120" class="Symbol">=</a> <a id="11122" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a>


<a id="trueIsTrue"></a><a id="11126" href="NahasTutorialModule.html#11126" class="Function">trueIsTrue</a> <a id="11137" class="Symbol">:</a> <a id="11139" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="11141" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a>
<a id="11146" href="NahasTutorialModule.html#11126" class="Function">trueIsTrue</a> <a id="11157" class="Symbol">=</a> <a id="11159" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>

</pre>

<p>If you do "C-c C-t" in the hole, it show you the simplified type
of the goal.  In the above proof, it was just "⊤".  So I filled in "tt".</p>

<pre class="Agda">
<a id="eqb"></a><a id="11316" href="NahasTutorialModule.html#11316" class="Function">eqb</a> <a id="11320" class="Symbol">:</a> <a id="11322" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a> <a id="11327" class="Symbol">→</a> <a id="11329" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a> <a id="11334" class="Symbol">→</a> <a id="11336" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a>
<a id="11341" href="NahasTutorialModule.html#11316" class="Function">eqb</a> <a id="11345" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a>  <a id="11351" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a>  <a id="11357" class="Symbol">=</a> <a id="11359" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a>
<a id="11364" href="NahasTutorialModule.html#11316" class="Function">eqb</a> <a id="11368" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a>  <a id="11374" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="11380" class="Symbol">=</a> <a id="11382" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a>
<a id="11388" href="NahasTutorialModule.html#11316" class="Function">eqb</a> <a id="11392" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="11398" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a>  <a id="11404" class="Symbol">=</a> <a id="11406" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a>
<a id="11412" href="NahasTutorialModule.html#11316" class="Function">eqb</a> <a id="11416" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="11422" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="11428" class="Symbol">=</a> <a id="11430" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a>

<a id="notEqbTrueFalse"></a><a id="11436" href="NahasTutorialModule.html#11436" class="Function">notEqbTrueFalse</a> <a id="11452" class="Symbol">:</a> <a id="11454" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a><a id="11455" class="Symbol">(</a><a id="11456" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="11458" class="Symbol">(</a><a id="11459" href="NahasTutorialModule.html#11316" class="Function">eqb</a> <a id="11463" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="11468" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a><a id="11473" class="Symbol">))</a>
<a id="11476" href="NahasTutorialModule.html#11436" class="Function">notEqbTrueFalse</a> <a id="11492" class="Symbol">()</a>

</pre>

<p>I took some time to figure out what was happening here.  But the value
resolved to type ⊥ and I could say there could be no argument of that
type.</p>

<pre class="Agda">
<a id="eqbaa"></a><a id="11658" href="NahasTutorialModule.html#11658" class="Function">eqbaa</a> <a id="11664" class="Symbol">:</a> <a id="11666" class="Symbol">(</a><a id="11667" href="NahasTutorialModule.html#11667" class="Bound">a</a> <a id="11669" class="Symbol">:</a> <a id="11671" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a><a id="11675" class="Symbol">)</a> <a id="11677" class="Symbol">→</a> <a id="11679" class="Symbol">(</a><a id="11680" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="11682" class="Symbol">(</a><a id="11683" href="NahasTutorialModule.html#11316" class="Function">eqb</a> <a id="11687" href="NahasTutorialModule.html#11667" class="Bound">a</a> <a id="11689" href="NahasTutorialModule.html#11667" class="Bound">a</a><a id="11690" class="Symbol">))</a>
<a id="11693" href="NahasTutorialModule.html#11658" class="Function">eqbaa</a> <a id="11699" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="11704" class="Symbol">=</a> <a id="11706" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>
<a id="11709" href="NahasTutorialModule.html#11658" class="Function">eqbaa</a> <a id="11715" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="11721" class="Symbol">=</a> <a id="11723" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>

</pre>

<p>Simple proof by cases.</p>

<pre class="Agda">
<a id="eqbat"></a><a id="11765" href="NahasTutorialModule.html#11765" class="Function">eqbat</a> <a id="11771" class="Symbol">:</a> <a id="11773" class="Symbol">(</a><a id="11774" href="NahasTutorialModule.html#11774" class="Bound">a</a> <a id="11776" class="Symbol">:</a> <a id="11778" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a><a id="11782" class="Symbol">)</a> <a id="11784" class="Symbol">→</a> <a id="11786" class="Symbol">(</a><a id="11787" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="11789" class="Symbol">(</a><a id="11790" href="NahasTutorialModule.html#11316" class="Function">eqb</a> <a id="11794" href="NahasTutorialModule.html#11774" class="Bound">a</a> <a id="11796" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a><a id="11800" class="Symbol">))</a> <a id="11803" class="Symbol">→</a> <a id="11805" class="Symbol">(</a><a id="11806" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="11808" href="NahasTutorialModule.html#11774" class="Bound">a</a><a id="11809" class="Symbol">)</a>
<a id="11811" href="NahasTutorialModule.html#11765" class="Function">eqbat</a> <a id="11817" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="11822" href="NahasTutorialModule.html#11822" class="Bound">x</a> <a id="11824" class="Symbol">=</a> <a id="11826" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>

</pre>

<p>When I split on cases of "a", there was only 1.
The simplified goal shown by "C-c C-t" showed it was type "⊤",
which is solved by "tt".</p>

<p>"or" in Agda is the Sum type.</p>

<pre class="Agda">
<a id="12012" class="Keyword">data</a> <a id="_⊎_"></a><a id="12017" href="NahasTutorialModule.html#12017" class="Datatype Operator">_⊎_</a> <a id="12021" class="Symbol">(</a><a id="12022" href="NahasTutorialModule.html#12022" class="Bound">A</a> <a id="12024" class="Symbol">:</a> <a id="12026" class="PrimitiveType">Set</a><a id="12029" class="Symbol">)</a> <a id="12031" class="Symbol">(</a><a id="12032" href="NahasTutorialModule.html#12032" class="Bound">B</a> <a id="12034" class="Symbol">:</a> <a id="12036" class="PrimitiveType">Set</a><a id="12039" class="Symbol">)</a> <a id="12041" class="Symbol">:</a> <a id="12043" class="PrimitiveType">Set</a> <a id="12047" class="Keyword">where</a>
  <a id="_⊎_.inj₁"></a><a id="12055" href="NahasTutorialModule.html#12055" class="InductiveConstructor">inj₁</a> <a id="12060" class="Symbol">:</a> <a id="12062" class="Symbol">(</a><a id="12063" href="NahasTutorialModule.html#12063" class="Bound">x</a> <a id="12065" class="Symbol">:</a> <a id="12067" href="NahasTutorialModule.html#12022" class="Bound">A</a><a id="12068" class="Symbol">)</a> <a id="12070" class="Symbol">→</a> <a id="12072" href="NahasTutorialModule.html#12022" class="Bound">A</a> <a id="12074" href="NahasTutorialModule.html#12017" class="Datatype Operator">⊎</a> <a id="12076" href="NahasTutorialModule.html#12032" class="Bound">B</a>
  <a id="_⊎_.inj₂"></a><a id="12080" href="NahasTutorialModule.html#12080" class="InductiveConstructor">inj₂</a> <a id="12085" class="Symbol">:</a> <a id="12087" class="Symbol">(</a><a id="12088" href="NahasTutorialModule.html#12088" class="Bound">y</a> <a id="12090" class="Symbol">:</a> <a id="12092" href="NahasTutorialModule.html#12032" class="Bound">B</a><a id="12093" class="Symbol">)</a> <a id="12095" class="Symbol">→</a> <a id="12097" href="NahasTutorialModule.html#12022" class="Bound">A</a> <a id="12099" href="NahasTutorialModule.html#12017" class="Datatype Operator">⊎</a> <a id="12101" href="NahasTutorialModule.html#12032" class="Bound">B</a>

</pre>

<p>Enter '⊎' with "\u+" or "\uplus".
Enter "inj₁" with "inj_1".</p>

<pre class="Agda">
<a id="leftOr"></a><a id="12181" href="NahasTutorialModule.html#12181" class="Function">leftOr</a> <a id="12188" class="Symbol">:</a> <a id="12190" class="Symbol">(</a><a id="12191" href="NahasTutorialModule.html#12191" class="Bound">A</a> <a id="12193" href="NahasTutorialModule.html#12193" class="Bound">B</a> <a id="12195" class="Symbol">:</a> <a id="12197" class="PrimitiveType">Set</a><a id="12200" class="Symbol">)</a> <a id="12202" class="Symbol">→</a> <a id="12204" href="NahasTutorialModule.html#12191" class="Bound">A</a> <a id="12206" class="Symbol">→</a> <a id="12208" class="Symbol">(</a><a id="12209" href="NahasTutorialModule.html#12191" class="Bound">A</a> <a id="12211" href="NahasTutorialModule.html#12017" class="Datatype Operator">⊎</a> <a id="12213" href="NahasTutorialModule.html#12193" class="Bound">B</a><a id="12214" class="Symbol">)</a>
<a id="12216" href="NahasTutorialModule.html#12181" class="Function">leftOr</a> <a id="12223" href="NahasTutorialModule.html#12223" class="Bound">A</a> <a id="12225" href="NahasTutorialModule.html#12225" class="Bound">B</a> <a id="12227" href="NahasTutorialModule.html#12227" class="Bound">a</a> <a id="12229" class="Symbol">=</a> <a id="12231" href="NahasTutorialModule.html#12055" class="InductiveConstructor">inj₁</a> <a id="12236" href="NahasTutorialModule.html#12227" class="Bound">a</a>

<a id="orCommutes"></a><a id="12239" href="NahasTutorialModule.html#12239" class="Function">orCommutes</a> <a id="12250" class="Symbol">:</a> <a id="12252" class="Symbol">(</a><a id="12253" href="NahasTutorialModule.html#12253" class="Bound">A</a> <a id="12255" href="NahasTutorialModule.html#12255" class="Bound">B</a> <a id="12257" class="Symbol">:</a> <a id="12259" class="PrimitiveType">Set</a><a id="12262" class="Symbol">)</a> <a id="12264" class="Symbol">→</a> <a id="12266" class="Symbol">(</a><a id="12267" href="NahasTutorialModule.html#12253" class="Bound">A</a> <a id="12269" href="NahasTutorialModule.html#12017" class="Datatype Operator">⊎</a> <a id="12271" href="NahasTutorialModule.html#12255" class="Bound">B</a><a id="12272" class="Symbol">)</a> <a id="12274" class="Symbol">→</a> <a id="12276" class="Symbol">(</a><a id="12277" href="NahasTutorialModule.html#12255" class="Bound">B</a> <a id="12279" href="NahasTutorialModule.html#12017" class="Datatype Operator">⊎</a> <a id="12281" href="NahasTutorialModule.html#12253" class="Bound">A</a><a id="12282" class="Symbol">)</a>
<a id="12284" href="NahasTutorialModule.html#12239" class="Function">orCommutes</a> <a id="12295" href="NahasTutorialModule.html#12295" class="Bound">A</a> <a id="12297" href="NahasTutorialModule.html#12297" class="Bound">B</a> <a id="12299" class="Symbol">(</a><a id="12300" href="NahasTutorialModule.html#12055" class="InductiveConstructor">inj₁</a> <a id="12305" href="NahasTutorialModule.html#12305" class="Bound">a</a><a id="12306" class="Symbol">)</a> <a id="12308" class="Symbol">=</a> <a id="12310" href="NahasTutorialModule.html#12080" class="InductiveConstructor">inj₂</a> <a id="12315" href="NahasTutorialModule.html#12305" class="Bound">a</a>
<a id="12317" href="NahasTutorialModule.html#12239" class="Function">orCommutes</a> <a id="12328" href="NahasTutorialModule.html#12328" class="Bound">A</a> <a id="12330" href="NahasTutorialModule.html#12330" class="Bound">B</a> <a id="12332" class="Symbol">(</a><a id="12333" href="NahasTutorialModule.html#12080" class="InductiveConstructor">inj₂</a> <a id="12338" href="NahasTutorialModule.html#12338" class="Bound">b</a><a id="12339" class="Symbol">)</a> <a id="12341" class="Symbol">=</a> <a id="12343" href="NahasTutorialModule.html#12055" class="InductiveConstructor">inj₁</a> <a id="12348" href="NahasTutorialModule.html#12338" class="Bound">b</a>

<a id="12351" class="Keyword">data</a> <a id="_×_"></a><a id="12356" href="NahasTutorialModule.html#12356" class="Datatype Operator">_×_</a> <a id="12360" class="Symbol">(</a><a id="12361" href="NahasTutorialModule.html#12361" class="Bound">A</a> <a id="12363" href="NahasTutorialModule.html#12363" class="Bound">B</a> <a id="12365" class="Symbol">:</a> <a id="12367" class="PrimitiveType">Set</a><a id="12370" class="Symbol">)</a> <a id="12372" class="Symbol">:</a> <a id="12374" class="PrimitiveType">Set</a> <a id="12378" class="Keyword">where</a>
  <a id="_×_._,′_"></a><a id="12386" href="NahasTutorialModule.html#12386" class="InductiveConstructor Operator">_,′_</a> <a id="12391" class="Symbol">:</a> <a id="12393" href="NahasTutorialModule.html#12361" class="Bound">A</a> <a id="12395" class="Symbol">→</a> <a id="12397" href="NahasTutorialModule.html#12363" class="Bound">B</a> <a id="12399" class="Symbol">→</a> <a id="12401" href="NahasTutorialModule.html#12361" class="Bound">A</a> <a id="12403" href="NahasTutorialModule.html#12356" class="Datatype Operator">×</a> <a id="12405" href="NahasTutorialModule.html#12363" class="Bound">B</a>

</pre>

<p>Enter '×' with "\x".
Enter '′' with "\prime" or "\'1"</p>

<pre class="Agda">
<a id="bothAnd"></a><a id="12477" href="NahasTutorialModule.html#12477" class="Function">bothAnd</a> <a id="12485" class="Symbol">:</a> <a id="12487" class="Symbol">(</a><a id="12488" href="NahasTutorialModule.html#12488" class="Bound">A</a> <a id="12490" href="NahasTutorialModule.html#12490" class="Bound">B</a> <a id="12492" class="Symbol">:</a> <a id="12494" class="PrimitiveType">Set</a><a id="12497" class="Symbol">)</a> <a id="12499" class="Symbol">→</a> <a id="12501" href="NahasTutorialModule.html#12488" class="Bound">A</a> <a id="12503" class="Symbol">→</a> <a id="12505" href="NahasTutorialModule.html#12490" class="Bound">B</a> <a id="12507" class="Symbol">→</a> <a id="12509" href="NahasTutorialModule.html#12488" class="Bound">A</a> <a id="12511" href="NahasTutorialModule.html#12356" class="Datatype Operator">×</a> <a id="12513" href="NahasTutorialModule.html#12490" class="Bound">B</a>
<a id="12515" href="NahasTutorialModule.html#12477" class="Function">bothAnd</a> <a id="12523" href="NahasTutorialModule.html#12523" class="Bound">A</a> <a id="12525" href="NahasTutorialModule.html#12525" class="Bound">B</a> <a id="12527" href="NahasTutorialModule.html#12527" class="Bound">a</a> <a id="12529" href="NahasTutorialModule.html#12529" class="Bound">b</a> <a id="12531" class="Symbol">=</a> <a id="12533" href="NahasTutorialModule.html#12527" class="Bound">a</a> <a id="12535" href="NahasTutorialModule.html#12386" class="InductiveConstructor Operator">,′</a> <a id="12538" href="NahasTutorialModule.html#12529" class="Bound">b</a>

</pre>

<p>Eventually was able to put "<em>,′</em>" in the hole and use "C-c C-r"</p>

<pre class="Agda">
<a id="andCommutes"></a><a id="12620" href="NahasTutorialModule.html#12620" class="Function">andCommutes</a> <a id="12632" class="Symbol">:</a> <a id="12634" class="Symbol">(</a><a id="12635" href="NahasTutorialModule.html#12635" class="Bound">A</a> <a id="12637" href="NahasTutorialModule.html#12637" class="Bound">B</a> <a id="12639" class="Symbol">:</a> <a id="12641" class="PrimitiveType">Set</a><a id="12644" class="Symbol">)</a> <a id="12646" class="Symbol">→</a> <a id="12648" class="Symbol">(</a><a id="12649" href="NahasTutorialModule.html#12635" class="Bound">A</a> <a id="12651" href="NahasTutorialModule.html#12356" class="Datatype Operator">×</a> <a id="12653" href="NahasTutorialModule.html#12637" class="Bound">B</a><a id="12654" class="Symbol">)</a> <a id="12656" class="Symbol">→</a> <a id="12658" class="Symbol">(</a><a id="12659" href="NahasTutorialModule.html#12637" class="Bound">B</a> <a id="12661" href="NahasTutorialModule.html#12356" class="Datatype Operator">×</a> <a id="12663" href="NahasTutorialModule.html#12635" class="Bound">A</a><a id="12664" class="Symbol">)</a>
<a id="12666" href="NahasTutorialModule.html#12620" class="Function">andCommutes</a> <a id="12678" href="NahasTutorialModule.html#12678" class="Bound">A</a> <a id="12680" href="NahasTutorialModule.html#12680" class="Bound">B</a> <a id="12682" class="Symbol">(</a><a id="12683" href="NahasTutorialModule.html#12683" class="Bound">a</a> <a id="12685" href="NahasTutorialModule.html#12386" class="InductiveConstructor Operator">,′</a> <a id="12688" href="NahasTutorialModule.html#12688" class="Bound">b</a><a id="12689" class="Symbol">)</a> <a id="12691" class="Symbol">=</a> <a id="12693" href="NahasTutorialModule.html#12688" class="Bound">b</a> <a id="12695" href="NahasTutorialModule.html#12386" class="InductiveConstructor Operator">,′</a> <a id="12698" href="NahasTutorialModule.html#12683" class="Bound">a</a>

<a id="_&amp;&amp;_"></a><a id="12701" href="NahasTutorialModule.html#12701" class="Function Operator">_&amp;&amp;_</a> <a id="12706" class="Symbol">:</a> <a id="12708" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a> <a id="12713" class="Symbol">-&gt;</a> <a id="12716" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a> <a id="12721" class="Symbol">-&gt;</a> <a id="12724" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a>
<a id="12729" href="NahasTutorialModule.html#12701" class="Function Operator">_&amp;&amp;_</a> <a id="12734" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="12739" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="12744" class="Symbol">=</a> <a id="12746" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a>
<a id="12751" href="NahasTutorialModule.html#12701" class="CatchallClause Function Operator">_&amp;&amp;_</a><a id="12755" class="CatchallClause"> </a><a id="12756" class="CatchallClause Symbol">_</a><a id="12757" class="CatchallClause"> </a><a id="12758" class="CatchallClause Symbol">_</a> <a id="12760" class="Symbol">=</a> <a id="12762" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a>

</pre>

<p>If you put _ in a definition, it matches all other cases.</p>

<pre class="Agda">
<a id="_||_"></a><a id="12842" href="NahasTutorialModule.html#12842" class="Function Operator">_||_</a> <a id="12847" class="Symbol">:</a> <a id="12849" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a> <a id="12854" class="Symbol">-&gt;</a> <a id="12857" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a> <a id="12862" class="Symbol">-&gt;</a> <a id="12865" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a>
<a id="12870" href="NahasTutorialModule.html#12842" class="Function Operator">_||_</a> <a id="12875" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="12881" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="12887" class="Symbol">=</a> <a id="12889" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a>
<a id="12895" href="NahasTutorialModule.html#12842" class="CatchallClause Function Operator">_||_</a><a id="12899" class="CatchallClause"> </a><a id="12900" class="CatchallClause Symbol">_</a><a id="12901" class="CatchallClause"> </a><a id="12902" class="CatchallClause Symbol">_</a> <a id="12904" class="Symbol">=</a> <a id="12906" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a>

</pre>

<p>I found the following definition of iff on a webpage, not the standard library</p>

<pre class="Agda">
<a id="_iff_"></a><a id="13006" href="NahasTutorialModule.html#13006" class="Function Operator">_iff_</a> <a id="13012" class="Symbol">:</a> <a id="13014" class="PrimitiveType">Set</a> <a id="13018" class="Symbol">→</a> <a id="13020" class="PrimitiveType">Set</a> <a id="13024" class="Symbol">→</a> <a id="13026" class="PrimitiveType">Set</a>
<a id="13030" href="NahasTutorialModule.html#13006" class="Function Operator">_iff_</a> <a id="13036" href="NahasTutorialModule.html#13036" class="Bound">A</a> <a id="13038" href="NahasTutorialModule.html#13038" class="Bound">B</a> <a id="13040" class="Symbol">=</a> <a id="13042" class="Symbol">(</a><a id="13043" href="NahasTutorialModule.html#13036" class="Bound">A</a> <a id="13045" class="Symbol">→</a> <a id="13047" href="NahasTutorialModule.html#13038" class="Bound">B</a><a id="13048" class="Symbol">)</a> <a id="13050" href="NahasTutorialModule.html#12356" class="Datatype Operator">×</a> <a id="13052" class="Symbol">(</a><a id="13053" href="NahasTutorialModule.html#13038" class="Bound">B</a> <a id="13055" class="Symbol">→</a> <a id="13057" href="NahasTutorialModule.html#13036" class="Bound">A</a><a id="13058" class="Symbol">)</a>

<a id="orbIsOrHelper"></a><a id="13061" href="NahasTutorialModule.html#13061" class="Function">orbIsOrHelper</a> <a id="13075" class="Symbol">:</a> <a id="13077" class="Symbol">(</a><a id="13078" href="NahasTutorialModule.html#13078" class="Bound">A</a> <a id="13080" href="NahasTutorialModule.html#13080" class="Bound">B</a> <a id="13082" class="Symbol">:</a> <a id="13084" class="PrimitiveType">Set</a><a id="13087" class="Symbol">)</a> <a id="13089" class="Symbol">-&gt;</a> <a id="13092" class="Symbol">(</a><a id="13093" href="NahasTutorialModule.html#13078" class="Bound">A</a> <a id="13095" href="NahasTutorialModule.html#12017" class="Datatype Operator">⊎</a> <a id="13097" href="NahasTutorialModule.html#13080" class="Bound">B</a><a id="13098" class="Symbol">)</a> <a id="13100" class="Symbol">→</a> <a id="13102" href="NahasTutorialModule.html#7361" class="Record">⊤</a>
<a id="13104" href="NahasTutorialModule.html#13061" class="Function">orbIsOrHelper</a> <a id="13118" class="Symbol">_</a> <a id="13120" class="Symbol">_</a> <a id="13122" class="Symbol">_</a> <a id="13124" class="Symbol">=</a> <a id="13126" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>

<a id="orbIsOrHelper2"></a><a id="13130" href="NahasTutorialModule.html#13130" class="Function">orbIsOrHelper2</a> <a id="13145" class="Symbol">:</a> <a id="13147" class="Symbol">(</a><a id="13148" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a> <a id="13150" href="NahasTutorialModule.html#12017" class="Datatype Operator">⊎</a> <a id="13152" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a><a id="13153" class="Symbol">)</a> <a id="13155" class="Symbol">→</a> <a id="13157" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a>
<a id="13159" href="NahasTutorialModule.html#13130" class="Function">orbIsOrHelper2</a> <a id="13174" class="Symbol">(</a><a id="13175" href="NahasTutorialModule.html#12055" class="InductiveConstructor">inj₁</a> <a id="13180" href="NahasTutorialModule.html#13180" class="Bound">x</a><a id="13181" class="Symbol">)</a> <a id="13183" class="Symbol">=</a> <a id="13185" href="NahasTutorialModule.html#13180" class="Bound">x</a>
<a id="13187" href="NahasTutorialModule.html#13130" class="Function">orbIsOrHelper2</a> <a id="13202" class="Symbol">(</a><a id="13203" href="NahasTutorialModule.html#12080" class="InductiveConstructor">inj₂</a> <a id="13208" href="NahasTutorialModule.html#13208" class="Bound">y</a><a id="13209" class="Symbol">)</a> <a id="13211" class="Symbol">=</a> <a id="13213" href="NahasTutorialModule.html#13208" class="Bound">y</a>

<a id="orbIsOr"></a><a id="13216" href="NahasTutorialModule.html#13216" class="Function">orbIsOr</a> <a id="13224" class="Symbol">:</a> <a id="13226" class="Symbol">(</a><a id="13227" href="NahasTutorialModule.html#13227" class="Bound">a</a> <a id="13229" href="NahasTutorialModule.html#13229" class="Bound">b</a> <a id="13231" class="Symbol">:</a> <a id="13233" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a><a id="13237" class="Symbol">)</a> <a id="13239" class="Symbol">→</a> <a id="13241" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="13243" class="Symbol">(</a><a id="13244" href="NahasTutorialModule.html#13227" class="Bound">a</a> <a id="13246" href="NahasTutorialModule.html#12842" class="Function Operator">||</a> <a id="13249" href="NahasTutorialModule.html#13229" class="Bound">b</a><a id="13250" class="Symbol">)</a> <a id="13252" href="NahasTutorialModule.html#13006" class="Function Operator">iff</a> <a id="13256" class="Symbol">(</a><a id="13257" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="13259" href="NahasTutorialModule.html#13227" class="Bound">a</a> <a id="13261" href="NahasTutorialModule.html#12017" class="Datatype Operator">⊎</a> <a id="13263" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="13265" href="NahasTutorialModule.html#13229" class="Bound">b</a><a id="13266" class="Symbol">)</a>
<a id="13268" href="NahasTutorialModule.html#13216" class="Function">orbIsOr</a> <a id="13276" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="13281" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="13286" class="Symbol">=</a> <a id="13288" href="NahasTutorialModule.html#12055" class="InductiveConstructor">inj₁</a> <a id="13293" href="NahasTutorialModule.html#12386" class="InductiveConstructor Operator">,′</a> <a id="13296" href="NahasTutorialModule.html#13061" class="Function">orbIsOrHelper</a> <a id="13310" href="NahasTutorialModule.html#7361" class="Record">⊤</a> <a id="13312" href="NahasTutorialModule.html#7361" class="Record">⊤</a>
<a id="13314" href="NahasTutorialModule.html#13216" class="Function">orbIsOr</a> <a id="13322" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="13327" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="13333" class="Symbol">=</a> <a id="13335" href="NahasTutorialModule.html#12055" class="InductiveConstructor">inj₁</a> <a id="13340" href="NahasTutorialModule.html#12386" class="InductiveConstructor Operator">,′</a> <a id="13343" href="NahasTutorialModule.html#13061" class="Function">orbIsOrHelper</a> <a id="13357" href="NahasTutorialModule.html#7361" class="Record">⊤</a> <a id="13359" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a>
<a id="13361" href="NahasTutorialModule.html#13216" class="Function">orbIsOr</a> <a id="13369" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="13375" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="13380" class="Symbol">=</a> <a id="13382" href="NahasTutorialModule.html#12080" class="InductiveConstructor">inj₂</a> <a id="13387" href="NahasTutorialModule.html#12386" class="InductiveConstructor Operator">,′</a> <a id="13390" href="NahasTutorialModule.html#13061" class="Function">orbIsOrHelper</a> <a id="13404" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a> <a id="13406" href="NahasTutorialModule.html#7361" class="Record">⊤</a>
<a id="13408" href="NahasTutorialModule.html#13216" class="Function">orbIsOr</a> <a id="13416" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="13422" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="13428" class="Symbol">=</a> <a id="13430" href="NahasTutorialModule.html#12055" class="InductiveConstructor">inj₁</a> <a id="13435" href="NahasTutorialModule.html#12386" class="InductiveConstructor Operator">,′</a> <a id="13438" href="NahasTutorialModule.html#13130" class="Function">orbIsOrHelper2</a>

</pre>

<p>At this point in the Coq tutorial, I wrote a comment saying "we're not
in Kansas any more!"  And I definitely feel that here too.  I needed two
helper functions.  It doesn't feel as understandable as the Coq proof.
I cannot follow it.</p>

<p>I didn't seem as easy to split the proof into two directions (left
implies right and right implies left).  Can I do it that way?  Let me
try...</p>

<pre class="Agda">
<a id="andbIsAndLeft"></a><a id="13849" href="NahasTutorialModule.html#13849" class="Function">andbIsAndLeft</a> <a id="13863" class="Symbol">:</a> <a id="13865" class="Symbol">(</a><a id="13866" href="NahasTutorialModule.html#13866" class="Bound">a</a> <a id="13868" href="NahasTutorialModule.html#13868" class="Bound">b</a> <a id="13870" class="Symbol">:</a> <a id="13872" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a><a id="13876" class="Symbol">)</a> <a id="13878" class="Symbol">→</a> <a id="13880" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="13882" class="Symbol">(</a><a id="13883" href="NahasTutorialModule.html#13866" class="Bound">a</a> <a id="13885" href="NahasTutorialModule.html#12701" class="Function Operator">&amp;&amp;</a> <a id="13888" href="NahasTutorialModule.html#13868" class="Bound">b</a><a id="13889" class="Symbol">)</a> <a id="13891" class="Symbol">→</a> <a id="13893" class="Symbol">(</a><a id="13894" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="13896" href="NahasTutorialModule.html#13866" class="Bound">a</a> <a id="13898" href="NahasTutorialModule.html#12356" class="Datatype Operator">×</a> <a id="13900" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="13902" href="NahasTutorialModule.html#13868" class="Bound">b</a><a id="13903" class="Symbol">)</a>
<a id="13905" href="NahasTutorialModule.html#13849" class="Function">andbIsAndLeft</a> <a id="13919" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="13924" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="13929" href="NahasTutorialModule.html#13929" class="Bound">x</a> <a id="13931" class="Symbol">=</a> <a id="13933" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a> <a id="13936" href="NahasTutorialModule.html#12386" class="InductiveConstructor Operator">,′</a> <a id="13939" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>

<a id="andbIsAndRight"></a><a id="13943" href="NahasTutorialModule.html#13943" class="Function">andbIsAndRight</a> <a id="13958" class="Symbol">:</a> <a id="13960" class="Symbol">(</a><a id="13961" href="NahasTutorialModule.html#13961" class="Bound">a</a> <a id="13963" href="NahasTutorialModule.html#13963" class="Bound">b</a> <a id="13965" class="Symbol">:</a> <a id="13967" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a><a id="13971" class="Symbol">)</a> <a id="13973" class="Symbol">→</a> <a id="13975" class="Symbol">(</a><a id="13976" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="13978" href="NahasTutorialModule.html#13961" class="Bound">a</a> <a id="13980" href="NahasTutorialModule.html#12356" class="Datatype Operator">×</a> <a id="13982" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="13984" href="NahasTutorialModule.html#13963" class="Bound">b</a><a id="13985" class="Symbol">)</a> <a id="13987" class="Symbol">→</a> <a id="13989" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="13991" class="Symbol">(</a><a id="13992" href="NahasTutorialModule.html#13961" class="Bound">a</a> <a id="13994" href="NahasTutorialModule.html#12701" class="Function Operator">&amp;&amp;</a> <a id="13997" href="NahasTutorialModule.html#13963" class="Bound">b</a><a id="13998" class="Symbol">)</a>
<a id="14000" href="NahasTutorialModule.html#13943" class="Function">andbIsAndRight</a> <a id="14015" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="14020" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="14025" class="Symbol">(</a><a id="14026" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a> <a id="14029" href="NahasTutorialModule.html#12386" class="InductiveConstructor Operator">,′</a> <a id="14032" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a><a id="14034" class="Symbol">)</a> <a id="14036" class="Symbol">=</a> <a id="14038" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>

<a id="andbIsAnd"></a><a id="14042" href="NahasTutorialModule.html#14042" class="Function">andbIsAnd</a> <a id="14052" class="Symbol">:</a> <a id="14054" class="Symbol">(</a><a id="14055" href="NahasTutorialModule.html#14055" class="Bound">a</a> <a id="14057" href="NahasTutorialModule.html#14057" class="Bound">b</a> <a id="14059" class="Symbol">:</a> <a id="14061" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a><a id="14065" class="Symbol">)</a> <a id="14067" class="Symbol">→</a> <a id="14069" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="14071" class="Symbol">(</a><a id="14072" href="NahasTutorialModule.html#14055" class="Bound">a</a> <a id="14074" href="NahasTutorialModule.html#12701" class="Function Operator">&amp;&amp;</a> <a id="14077" href="NahasTutorialModule.html#14057" class="Bound">b</a><a id="14078" class="Symbol">)</a> <a id="14080" href="NahasTutorialModule.html#13006" class="Function Operator">iff</a> <a id="14084" class="Symbol">(</a><a id="14085" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="14087" href="NahasTutorialModule.html#14055" class="Bound">a</a> <a id="14089" href="NahasTutorialModule.html#12356" class="Datatype Operator">×</a> <a id="14091" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="14093" href="NahasTutorialModule.html#14057" class="Bound">b</a><a id="14094" class="Symbol">)</a>
<a id="14096" href="NahasTutorialModule.html#14042" class="Function">andbIsAnd</a> <a id="14106" href="NahasTutorialModule.html#14106" class="Bound">a</a> <a id="14108" href="NahasTutorialModule.html#14108" class="Bound">b</a> <a id="14110" class="Symbol">=</a> <a id="14112" class="Symbol">(</a><a id="14113" href="NahasTutorialModule.html#13849" class="Function">andbIsAndLeft</a> <a id="14127" href="NahasTutorialModule.html#14106" class="Bound">a</a> <a id="14129" href="NahasTutorialModule.html#14108" class="Bound">b</a><a id="14130" class="Symbol">)</a> <a id="14132" href="NahasTutorialModule.html#12386" class="InductiveConstructor Operator">,′</a> <a id="14135" class="Symbol">(</a><a id="14136" href="NahasTutorialModule.html#13943" class="Function">andbIsAndRight</a> <a id="14151" href="NahasTutorialModule.html#14106" class="Bound">a</a> <a id="14153" href="NahasTutorialModule.html#14108" class="Bound">b</a><a id="14154" class="Symbol">)</a>


</pre>

<p>It wasn't hard to do it that way.  Agda took care of a lot
of the cases because they weren't possible.  There are no
instances of ⊥.</p>

<h2>Existence</h2>

<pre class="Agda">
<a id="14320" class="Keyword">record</a> <a id="Σ"></a><a id="14327" href="NahasTutorialModule.html#14327" class="Record">Σ</a> <a id="14329" class="Symbol">(</a><a id="14330" href="NahasTutorialModule.html#14330" class="Bound">A</a> <a id="14332" class="Symbol">:</a> <a id="14334" class="PrimitiveType">Set</a><a id="14337" class="Symbol">)</a> <a id="14339" class="Symbol">(</a><a id="14340" href="NahasTutorialModule.html#14340" class="Bound">B</a> <a id="14342" class="Symbol">:</a> <a id="14344" href="NahasTutorialModule.html#14330" class="Bound">A</a> <a id="14346" class="Symbol">→</a> <a id="14348" class="PrimitiveType">Set</a><a id="14351" class="Symbol">)</a> <a id="14353" class="Symbol">:</a> <a id="14355" class="PrimitiveType">Set</a> <a id="14359" class="Keyword">where</a>
  <a id="14367" class="Keyword">constructor</a> <a id="Σ._,_"></a><a id="14379" href="NahasTutorialModule.html#14379" class="InductiveConstructor Operator">_,_</a>
  <a id="14385" class="Keyword">field</a>
    <a id="Σ.fst"></a><a id="14395" href="NahasTutorialModule.html#14395" class="Field">fst</a> <a id="14399" class="Symbol">:</a> <a id="14401" href="NahasTutorialModule.html#14330" class="Bound">A</a>
    <a id="Σ.snd"></a><a id="14407" href="NahasTutorialModule.html#14407" class="Field">snd</a> <a id="14411" class="Symbol">:</a> <a id="14413" href="NahasTutorialModule.html#14340" class="Bound">B</a> <a id="14415" href="NahasTutorialModule.html#14395" class="Field">fst</a>

</pre>

<p>Enter 'Σ' with "\Sigma".</p>

<pre class="Agda">
<a id="∃"></a><a id="14460" href="NahasTutorialModule.html#14460" class="Function">∃</a> <a id="14462" class="Symbol">:</a> <a id="14464" class="Symbol">∀</a> <a id="14466" class="Symbol">{</a><a id="14467" href="NahasTutorialModule.html#14467" class="Bound">A</a> <a id="14469" class="Symbol">:</a> <a id="14471" class="PrimitiveType">Set</a><a id="14474" class="Symbol">}</a> <a id="14476" class="Symbol">→</a> <a id="14478" class="Symbol">(</a><a id="14479" href="NahasTutorialModule.html#14467" class="Bound">A</a> <a id="14481" class="Symbol">→</a> <a id="14483" class="PrimitiveType">Set</a><a id="14486" class="Symbol">)</a> <a id="14488" class="Symbol">→</a> <a id="14490" class="PrimitiveType">Set</a>
<a id="14494" href="NahasTutorialModule.html#14460" class="Function">∃</a> <a id="14496" class="Symbol">=</a> <a id="14498" href="NahasTutorialModule.html#14327" class="Record">Σ</a> <a id="14500" class="Symbol">_</a>

</pre>

<p>Enter '∃' with "\ex".</p>

<p>Notice the curly braces in "{A : Set}".  That makes the argument
implicit.  The compiler can determine it from the type of the next
argument "A → Set".</p>

<pre class="Agda">
<a id="basicPredicate"></a><a id="14693" href="NahasTutorialModule.html#14693" class="Function">basicPredicate</a> <a id="14708" class="Symbol">:</a> <a id="14710" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a> <a id="14715" class="Symbol">-&gt;</a> <a id="14718" class="PrimitiveType">Set</a>
<a id="14722" href="NahasTutorialModule.html#14693" class="Function">basicPredicate</a> <a id="14737" href="NahasTutorialModule.html#14737" class="Bound">a</a> <a id="14739" class="Symbol">=</a> <a id="14741" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="14743" class="Symbol">(</a><a id="14744" href="NahasTutorialModule.html#14737" class="Bound">a</a> <a id="14746" href="NahasTutorialModule.html#12701" class="Function Operator">&amp;&amp;</a> <a id="14749" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a><a id="14753" class="Symbol">)</a>

<a id="existsBasics"></a><a id="14756" href="NahasTutorialModule.html#14756" class="Function">existsBasics</a> <a id="14769" class="Symbol">:</a> <a id="14771" href="NahasTutorialModule.html#14460" class="Function">∃</a> <a id="14773" href="NahasTutorialModule.html#14693" class="Function">basicPredicate</a>
<a id="14788" href="NahasTutorialModule.html#14756" class="Function">existsBasics</a> <a id="14801" class="Symbol">=</a> <a id="14803" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="14808" href="NahasTutorialModule.html#14379" class="InductiveConstructor Operator">,</a> <a id="14810" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>

</pre>

<p>I solved this by putting the cursor in the old and typing "<em>,</em>"
followed by "C-c C-r".  Agda's Emacs mode created the pair.</p>

<p>"C-c C-t" did not fully evaluate the goal.  It's type was
"<code>basicPredicate true</code>".
I was able to use "C-c C-n" to evaluate "<code>basicPredicate true</code>"
as ⊤ and then supply "tt" as the second have of the pair.</p>

<pre class="Agda">
<a id="existsBasicsAgain"></a><a id="15159" href="NahasTutorialModule.html#15159" class="Function">existsBasicsAgain</a> <a id="15177" class="Symbol">:</a> <a id="15179" href="NahasTutorialModule.html#14460" class="Function">∃</a> <a id="15181" class="Symbol">(\</a> <a id="15184" href="NahasTutorialModule.html#15184" class="Bound">a</a> <a id="15186" class="Symbol">→</a> <a id="15188" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="15190" class="Symbol">(</a><a id="15191" href="NahasTutorialModule.html#15184" class="Bound">a</a> <a id="15193" href="NahasTutorialModule.html#12701" class="Function Operator">&amp;&amp;</a> <a id="15196" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a><a id="15200" class="Symbol">))</a>
<a id="15203" href="NahasTutorialModule.html#15159" class="Function">existsBasicsAgain</a> <a id="15221" class="Symbol">=</a> <a id="15223" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="15228" href="NahasTutorialModule.html#14379" class="InductiveConstructor Operator">,</a> <a id="15230" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>

</pre>

<p>Lambda terms (a.k.a. nameless functions) are written "\ variablename → expression".</p>

<pre class="Agda">
<a id="forallExists"></a><a id="15333" href="NahasTutorialModule.html#15333" class="Function">forallExists</a> <a id="15346" class="Symbol">:</a> <a id="15348" class="Symbol">(</a><a id="15349" href="NahasTutorialModule.html#15349" class="Bound">b</a> <a id="15351" class="Symbol">:</a> <a id="15353" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a><a id="15357" class="Symbol">)</a> <a id="15359" class="Symbol">→</a> <a id="15361" href="NahasTutorialModule.html#14460" class="Function">∃</a> <a id="15363" class="Symbol">(\</a> <a id="15366" href="NahasTutorialModule.html#15366" class="Bound">a</a> <a id="15368" class="Symbol">→</a> <a id="15370" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="15372" class="Symbol">(</a><a id="15373" href="NahasTutorialModule.html#11316" class="Function">eqb</a> <a id="15377" href="NahasTutorialModule.html#15366" class="Bound">a</a> <a id="15379" href="NahasTutorialModule.html#15349" class="Bound">b</a><a id="15380" class="Symbol">))</a>
<a id="15383" href="NahasTutorialModule.html#15333" class="Function">forallExists</a> <a id="15396" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="15401" class="Symbol">=</a> <a id="15403" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="15408" href="NahasTutorialModule.html#14379" class="InductiveConstructor Operator">,</a> <a id="15410" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>
<a id="15413" href="NahasTutorialModule.html#15333" class="Function">forallExists</a> <a id="15426" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="15432" class="Symbol">=</a> <a id="15434" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="15440" href="NahasTutorialModule.html#14379" class="InductiveConstructor Operator">,</a> <a id="15442" href="NahasTutorialModule.html#7389" class="InductiveConstructor">tt</a>

</pre>

<p>Strange that each case has enough information to evaluate down to ⊤
But, then again, the Coq proof is a case followed by simplification
and "exact I".</p>

<pre class="Agda">
<a id="forallExists2"></a><a id="15612" href="NahasTutorialModule.html#15612" class="Function">forallExists2</a> <a id="15626" class="Symbol">:</a> <a id="15628" class="Symbol">(</a><a id="15629" href="NahasTutorialModule.html#15629" class="Bound">b</a> <a id="15631" class="Symbol">:</a> <a id="15633" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a><a id="15637" class="Symbol">)</a> <a id="15639" class="Symbol">→</a> <a id="15641" href="NahasTutorialModule.html#14460" class="Function">∃</a> <a id="15643" class="Symbol">(\</a> <a id="15646" href="NahasTutorialModule.html#15646" class="Bound">a</a> <a id="15648" class="Symbol">→</a> <a id="15650" href="NahasTutorialModule.html#11085" class="Function">T</a> <a id="15652" class="Symbol">(</a><a id="15653" href="NahasTutorialModule.html#11316" class="Function">eqb</a> <a id="15657" href="NahasTutorialModule.html#15646" class="Bound">a</a> <a id="15659" href="NahasTutorialModule.html#15629" class="Bound">b</a><a id="15660" class="Symbol">))</a>
<a id="15663" href="NahasTutorialModule.html#15612" class="Function">forallExists2</a> <a id="15677" href="NahasTutorialModule.html#15677" class="Bound">b</a> <a id="15679" class="Symbol">=</a> <a id="15681" href="NahasTutorialModule.html#15677" class="Bound">b</a> <a id="15683" href="NahasTutorialModule.html#14379" class="InductiveConstructor Operator">,</a> <a id="15685" href="NahasTutorialModule.html#11658" class="Function">eqbaa</a> <a id="15691" href="NahasTutorialModule.html#15677" class="Bound">b</a>

</pre>

<p>Reusing earlier proof.  Was able to type it in directly.</p>

<pre class="Agda">
<a id="forallExistsSet"></a><a id="15766" href="NahasTutorialModule.html#15766" class="Function">forallExistsSet</a> <a id="15782" class="Symbol">:</a> <a id="15784" class="Symbol">(</a><a id="15785" href="NahasTutorialModule.html#15785" class="Bound">A</a> <a id="15787" class="Symbol">:</a> <a id="15789" class="PrimitiveType">Set</a><a id="15792" class="Symbol">)</a> <a id="15794" class="Symbol">→</a> <a id="15796" class="Symbol">(</a><a id="15797" href="NahasTutorialModule.html#15797" class="Bound">P</a> <a id="15799" class="Symbol">:</a> <a id="15801" href="NahasTutorialModule.html#15785" class="Bound">A</a> <a id="15803" class="Symbol">→</a> <a id="15805" class="PrimitiveType">Set</a><a id="15808" class="Symbol">)</a> <a id="15810" class="Symbol">→</a> <a id="15812" class="Symbol">(∀</a> <a id="15815" href="NahasTutorialModule.html#15815" class="Bound">x</a> <a id="15817" class="Symbol">→</a> <a id="15819" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a> <a id="15821" href="NahasTutorialModule.html#15797" class="Bound">P</a> <a id="15823" href="NahasTutorialModule.html#15815" class="Bound">x</a><a id="15824" class="Symbol">)</a> <a id="15826" class="Symbol">→</a> <a id="15828" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a> <a id="15830" class="Symbol">(</a><a id="15831" href="NahasTutorialModule.html#14460" class="Function">∃</a> <a id="15833" class="Symbol">(\</a> <a id="15836" href="NahasTutorialModule.html#15836" class="Bound">x</a> <a id="15838" class="Symbol">→</a> <a id="15840" href="NahasTutorialModule.html#15797" class="Bound">P</a> <a id="15842" href="NahasTutorialModule.html#15836" class="Bound">x</a><a id="15843" class="Symbol">))</a>
<a id="15846" href="NahasTutorialModule.html#15766" class="Function">forallExistsSet</a> <a id="15862" href="NahasTutorialModule.html#15862" class="Bound">A</a> <a id="15864" href="NahasTutorialModule.html#15864" class="Bound">P</a> <a id="15866" href="NahasTutorialModule.html#15866" class="Bound">forallxnotPx</a> <a id="15879" class="Symbol">(</a><a id="15880" href="NahasTutorialModule.html#15880" class="Bound">x</a> <a id="15882" href="NahasTutorialModule.html#14379" class="InductiveConstructor Operator">,</a> <a id="15884" href="NahasTutorialModule.html#15884" class="Bound">Px</a><a id="15886" class="Symbol">)</a> <a id="15888" class="Symbol">=</a> <a id="15890" class="Keyword">let</a> <a id="15894" href="NahasTutorialModule.html#15894" class="Bound">notPx</a> <a id="15900" class="Symbol">=</a> <a id="15902" href="NahasTutorialModule.html#15866" class="Bound">forallxnotPx</a> <a id="15915" href="NahasTutorialModule.html#15880" class="Bound">x</a> <a id="15917" class="Keyword">in</a> <a id="15920" href="NahasTutorialModule.html#9901" class="Function">absurd</a> <a id="15927" class="Symbol">(</a><a id="15928" href="NahasTutorialModule.html#15864" class="Bound">P</a> <a id="15930" href="NahasTutorialModule.html#15880" class="Bound">x</a><a id="15931" class="Symbol">)</a> <a id="15933" href="NahasTutorialModule.html#8184" class="Datatype">⊥</a> <a id="15935" href="NahasTutorialModule.html#15884" class="Bound">Px</a> <a id="15938" href="NahasTutorialModule.html#15894" class="Bound">notPx</a>

</pre>

<p>It took me a while to translate this statement from Coq to Agda.
I had to introduce "A : Set" to make it work.  I don't think I
lost much.</p>

<p>I'm still a little confused by ∀ in Agda.  It took me a while to
realize that I needed it before x.</p>

<p>Needed to use "absurd" because I cannot do case-of-false in Agda.</p>

<p>Really should use "{}" to make sets implicit in "absurd".  It took
some time to figure those out.  Mostly, I figured it out because
of good error messages.</p>

<pre class="Agda">
<a id="existsForallSet"></a><a id="16424" href="NahasTutorialModule.html#16424" class="Function">existsForallSet</a> <a id="16440" class="Symbol">:</a> <a id="16442" class="Symbol">(</a><a id="16443" href="NahasTutorialModule.html#16443" class="Bound">A</a> <a id="16445" class="Symbol">:</a> <a id="16447" class="PrimitiveType">Set</a><a id="16450" class="Symbol">)</a> <a id="16452" class="Symbol">→</a> <a id="16454" class="Symbol">(</a><a id="16455" href="NahasTutorialModule.html#16455" class="Bound">P</a> <a id="16457" class="Symbol">:</a> <a id="16459" href="NahasTutorialModule.html#16443" class="Bound">A</a> <a id="16461" class="Symbol">→</a> <a id="16463" class="PrimitiveType">Set</a><a id="16466" class="Symbol">)</a> <a id="16468" class="Symbol">→</a> <a id="16470" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a> <a id="16472" class="Symbol">(</a><a id="16473" href="NahasTutorialModule.html#14460" class="Function">∃</a> <a id="16475" class="Symbol">(\</a> <a id="16478" href="NahasTutorialModule.html#16478" class="Bound">x</a> <a id="16480" class="Symbol">→</a> <a id="16482" href="NahasTutorialModule.html#16455" class="Bound">P</a> <a id="16484" href="NahasTutorialModule.html#16478" class="Bound">x</a><a id="16485" class="Symbol">))</a> <a id="16488" class="Symbol">→</a> <a id="16490" class="Symbol">(∀</a> <a id="16493" href="NahasTutorialModule.html#16493" class="Bound">x</a> <a id="16495" class="Symbol">→</a> <a id="16497" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a> <a id="16499" href="NahasTutorialModule.html#16455" class="Bound">P</a> <a id="16501" href="NahasTutorialModule.html#16493" class="Bound">x</a><a id="16502" class="Symbol">)</a>
<a id="16504" href="NahasTutorialModule.html#16424" class="Function">existsForallSet</a> <a id="16520" href="NahasTutorialModule.html#16520" class="Bound">A</a> <a id="16522" href="NahasTutorialModule.html#16522" class="Bound">P</a> <a id="16524" href="NahasTutorialModule.html#16524" class="Bound">notexistxPx</a> <a id="16536" href="NahasTutorialModule.html#16536" class="Bound">x</a> <a id="16538" href="NahasTutorialModule.html#16538" class="Bound">Px</a> <a id="16541" class="Symbol">=</a> <a id="16543" href="NahasTutorialModule.html#16524" class="Bound">notexistxPx</a> <a id="16555" class="Symbol">(</a><a id="16556" href="NahasTutorialModule.html#16536" class="Bound">x</a> <a id="16558" href="NahasTutorialModule.html#14379" class="InductiveConstructor Operator">,</a> <a id="16560" href="NahasTutorialModule.html#16538" class="Bound">Px</a><a id="16562" class="Symbol">)</a>

</pre>

<p>This was actually pretty easy.</p>

<p>Agda has an alternative syntax for Sigma types, declared with the syntax keyword.</p>

<pre class="Agda">
<a id="16694" class="Keyword">syntax</a> <a id="16701" href="NahasTutorialModule.html#14327" class="Record">Σ</a> <a id="16703" class="Bound">A</a> <a id="16705" class="Symbol">(λ</a> <a id="16708" class="Bound">x</a> <a id="16710" class="Symbol">→</a> <a id="16712" class="Bound">B</a><a id="16713" class="Symbol">)</a> <a id="16715" class="Symbol">=</a> <a id="16717" class="Record">[</a> <a id="16719" class="Bound">x</a> <a id="16721" class="Record">∈</a> <a id="16723" class="Bound">A</a> <a id="16725" class="Record">]</a> <a id="16727" class="Bound">B</a>

</pre>

<h2>Equality</h2>

<p>We can import Agda's equality operator with this import:</p>

<pre class="Agda">
<a id="16815" class="Keyword">import</a> <a id="16822" href="Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="16860" class="Symbol">as</a> <a id="16863" class="Module">Eq</a>
<a id="16866" class="Keyword">open</a> <a id="16871" href="Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="16874" class="Keyword">using</a> <a id="16880" class="Symbol">(</a><a id="16881" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="16884" class="Symbol">;</a> <a id="16886" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="16890" class="Symbol">;</a> <a id="16892" href="Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a><a id="16896" class="Symbol">;</a> <a id="16898" href="Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a><a id="16901" class="Symbol">)</a>

</pre>

<p>data <em>≡</em> {A : Set} (x : A) : A → Set where
  refl : x ≡ x</p>

<p>Enter "≡" with "\==".</p>

<pre class="Agda">
<a id="equalityIsSymmetric"></a><a id="17000" href="NahasTutorialModule.html#17000" class="Function">equalityIsSymmetric</a> <a id="17020" class="Symbol">:</a> <a id="17022" class="Symbol">{</a><a id="17023" href="NahasTutorialModule.html#17023" class="Bound">A</a> <a id="17025" class="Symbol">:</a> <a id="17027" class="PrimitiveType">Set</a><a id="17030" class="Symbol">}</a> <a id="17032" class="Symbol">→</a> <a id="17034" class="Symbol">{</a><a id="17035" href="NahasTutorialModule.html#17035" class="Bound">x</a> <a id="17037" class="Symbol">:</a> <a id="17039" href="NahasTutorialModule.html#17023" class="Bound">A</a><a id="17040" class="Symbol">}</a> <a id="17042" class="Symbol">→</a> <a id="17044" class="Symbol">{</a><a id="17045" href="NahasTutorialModule.html#17045" class="Bound">y</a> <a id="17047" class="Symbol">:</a> <a id="17049" href="NahasTutorialModule.html#17023" class="Bound">A</a><a id="17050" class="Symbol">}</a> <a id="17052" class="Symbol">→</a> <a id="17054" href="NahasTutorialModule.html#17035" class="Bound">x</a> <a id="17056" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="17058" href="NahasTutorialModule.html#17045" class="Bound">y</a> <a id="17060" class="Symbol">→</a> <a id="17062" href="NahasTutorialModule.html#17045" class="Bound">y</a> <a id="17064" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="17066" href="NahasTutorialModule.html#17035" class="Bound">x</a>
<a id="17068" href="NahasTutorialModule.html#17000" class="Function">equalityIsSymmetric</a> <a id="17088" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="17093" class="Symbol">=</a> <a id="17095" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

</pre>

<p>Because "x ≡ y" has only one possible case for its constructor, that
must "unify" x and y to be the same.  The goal becomes something of
type "x ≡ x", which is solved by refl.</p>

<p>I didn't find an equivalent to "destruct" in Agda's Emacs mode.</p>

<pre class="Agda">
<a id="equalityIsTransitive"></a><a id="17357" href="NahasTutorialModule.html#17357" class="Function">equalityIsTransitive</a> <a id="17378" class="Symbol">:</a> <a id="17380" class="Symbol">{</a><a id="17381" href="NahasTutorialModule.html#17381" class="Bound">A</a> <a id="17383" class="Symbol">:</a> <a id="17385" class="PrimitiveType">Set</a><a id="17388" class="Symbol">}</a> <a id="17390" class="Symbol">→</a> <a id="17392" class="Symbol">{</a><a id="17393" href="NahasTutorialModule.html#17393" class="Bound">x</a> <a id="17395" class="Symbol">:</a> <a id="17397" href="NahasTutorialModule.html#17381" class="Bound">A</a><a id="17398" class="Symbol">}</a> <a id="17400" class="Symbol">→</a> <a id="17402" class="Symbol">{</a><a id="17403" href="NahasTutorialModule.html#17403" class="Bound">y</a> <a id="17405" class="Symbol">:</a> <a id="17407" href="NahasTutorialModule.html#17381" class="Bound">A</a><a id="17408" class="Symbol">}</a> <a id="17410" class="Symbol">→</a> <a id="17412" class="Symbol">{</a><a id="17413" href="NahasTutorialModule.html#17413" class="Bound">z</a> <a id="17415" class="Symbol">:</a> <a id="17417" href="NahasTutorialModule.html#17381" class="Bound">A</a><a id="17418" class="Symbol">}</a> <a id="17420" class="Symbol">→</a> <a id="17422" href="NahasTutorialModule.html#17393" class="Bound">x</a> <a id="17424" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="17426" href="NahasTutorialModule.html#17403" class="Bound">y</a> <a id="17428" class="Symbol">→</a> <a id="17430" href="NahasTutorialModule.html#17403" class="Bound">y</a> <a id="17432" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="17434" href="NahasTutorialModule.html#17413" class="Bound">z</a> <a id="17436" class="Symbol">→</a> <a id="17438" href="NahasTutorialModule.html#17393" class="Bound">x</a> <a id="17440" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="17442" href="NahasTutorialModule.html#17413" class="Bound">z</a>
<a id="17444" href="NahasTutorialModule.html#17357" class="Function">equalityIsTransitive</a> <a id="17465" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="17470" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="17475" class="Symbol">=</a> <a id="17477" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

</pre>

<p>Agda's Emacs mode inserted the ".x" when I entered x≡y followed by
"C-c C-c".  The "." means that the parameter is "inaccessible".  I'm
not sure exactly what that means.  The manual says that Agda confirms
the type, but doesn't check all the cases.  I guess that "refl"
determines the value for the ".x" parameters and Agda can figure out
that all cases are handled.</p>

<p>In Coq, I also proved this theorem by rewriting.  I'm not sure how to
do that in Agda, yet.  (NOTE: I later figured out that Agda doesn't
have rewriting.  More on that later.)</p>

<pre class="Agda">
<a id="andbSymmetric"></a><a id="18043" href="NahasTutorialModule.html#18043" class="Function">andbSymmetric</a> <a id="18057" class="Symbol">:</a> <a id="18059" class="Symbol">(</a><a id="18060" href="NahasTutorialModule.html#18060" class="Bound">a</a> <a id="18062" class="Symbol">:</a> <a id="18064" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a><a id="18068" class="Symbol">)</a> <a id="18070" class="Symbol">→</a> <a id="18072" class="Symbol">(</a><a id="18073" href="NahasTutorialModule.html#18073" class="Bound">b</a> <a id="18075" class="Symbol">:</a> <a id="18077" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a><a id="18081" class="Symbol">)</a> <a id="18083" class="Symbol">→</a> <a id="18085" class="Symbol">(</a> <a id="18087" href="NahasTutorialModule.html#18060" class="Bound">a</a> <a id="18089" href="NahasTutorialModule.html#12701" class="Function Operator">&amp;&amp;</a> <a id="18092" href="NahasTutorialModule.html#18073" class="Bound">b</a> <a id="18094" class="Symbol">)</a> <a id="18096" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="18098" class="Symbol">(</a> <a id="18100" href="NahasTutorialModule.html#18073" class="Bound">b</a> <a id="18102" href="NahasTutorialModule.html#12701" class="Function Operator">&amp;&amp;</a> <a id="18105" href="NahasTutorialModule.html#18060" class="Bound">a</a> <a id="18107" class="Symbol">)</a>
<a id="18109" href="NahasTutorialModule.html#18043" class="Function">andbSymmetric</a> <a id="18123" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="18128" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="18133" class="Symbol">=</a> <a id="18135" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="18140" href="NahasTutorialModule.html#18043" class="Function">andbSymmetric</a> <a id="18154" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="18159" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="18165" class="Symbol">=</a> <a id="18167" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="18172" href="NahasTutorialModule.html#18043" class="Function">andbSymmetric</a> <a id="18186" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="18192" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="18197" class="Symbol">=</a> <a id="18199" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="18204" href="NahasTutorialModule.html#18043" class="Function">andbSymmetric</a> <a id="18218" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="18224" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="18230" class="Symbol">=</a> <a id="18232" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

</pre>

<p>Pretty easy, just handle each case.</p>

<pre class="Agda">
<a id="_≢_"></a><a id="18290" href="NahasTutorialModule.html#18290" class="Function Operator">_≢_</a> <a id="18294" class="Symbol">:</a> <a id="18296" class="Symbol">{</a><a id="18297" href="NahasTutorialModule.html#18297" class="Bound">A</a> <a id="18299" class="Symbol">:</a> <a id="18301" class="PrimitiveType">Set</a><a id="18304" class="Symbol">}</a> <a id="18306" class="Symbol">→</a> <a id="18308" href="NahasTutorialModule.html#18297" class="Bound">A</a> <a id="18310" class="Symbol">→</a> <a id="18312" href="NahasTutorialModule.html#18297" class="Bound">A</a> <a id="18314" class="Symbol">→</a> <a id="18316" class="PrimitiveType">Set</a>
<a id="18320" href="NahasTutorialModule.html#18290" class="Function Operator">_≢_</a> <a id="18324" href="NahasTutorialModule.html#18324" class="Bound">x</a> <a id="18326" href="NahasTutorialModule.html#18326" class="Bound">y</a> <a id="18328" class="Symbol">=</a> <a id="18330" href="NahasTutorialModule.html#8630" class="Function Operator">¬</a> <a id="18332" class="Symbol">(</a><a id="18333" href="NahasTutorialModule.html#18324" class="Bound">x</a> <a id="18335" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="18337" href="NahasTutorialModule.html#18326" class="Bound">y</a><a id="18338" class="Symbol">)</a>


</pre>

<p>Enter '≢' with "\==n"</p>

<p>It took me a while to figure out what that definition had to be.</p>

<pre class="Agda">
<a id="negNega"></a><a id="18445" href="NahasTutorialModule.html#18445" class="Function">negNega</a> <a id="18453" class="Symbol">:</a> <a id="18455" class="Symbol">(</a><a id="18456" href="NahasTutorialModule.html#18456" class="Bound">a</a> <a id="18458" class="Symbol">:</a> <a id="18460" href="NahasTutorialModule.html#2462" class="Datatype">Bool</a><a id="18464" class="Symbol">)</a> <a id="18466" class="Symbol">→</a> <a id="18468" class="Symbol">(</a><a id="18469" href="NahasTutorialModule.html#18456" class="Bound">a</a> <a id="18471" href="NahasTutorialModule.html#18290" class="Function Operator">≢</a> <a id="18473" class="Symbol">(</a><a id="18474" href="NahasTutorialModule.html#2638" class="Function">not</a> <a id="18478" href="NahasTutorialModule.html#18456" class="Bound">a</a><a id="18479" class="Symbol">))</a>
<a id="18482" href="NahasTutorialModule.html#18445" class="Function">negNega</a> <a id="18490" href="NahasTutorialModule.html#2481" class="InductiveConstructor">true</a> <a id="18495" class="Symbol">()</a>
<a id="18498" href="NahasTutorialModule.html#18445" class="Function">negNega</a> <a id="18506" href="NahasTutorialModule.html#2495" class="InductiveConstructor">false</a> <a id="18512" class="Symbol">()</a>

</pre>

<p>Strange.  I needed two lines here.  With two lines, the compiler is
able to determine that each is absurd, but when I had a single line,
it was not able to do it.  But, I guess Coq was similar, in that I
needed to do "case a" first too.</p>

<h2>Natural Numbers and Induction</h2>

<pre class="Agda">
<a id="18803" class="Keyword">import</a> <a id="18810" href="Data.Nat.html" class="Module">Data.Nat</a>
<a id="18819" class="Keyword">open</a> <a id="18824" href="Data.Nat.html" class="Module">Data.Nat</a> <a id="18833" class="Keyword">using</a> <a id="18839" class="Symbol">(</a><a id="18840" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="18841" class="Symbol">;</a> <a id="18843" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="18847" class="Symbol">;</a> <a id="18849" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="18852" class="Symbol">;</a> <a id="18854" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">_+_</a><a id="18857" class="Symbol">)</a>

</pre>

<p>The "import" command loads Modules from a different file into this one.</p>

<p>The "open" command pulls names from another scope into this one.</p>

<p>They can be combined into a single line "open import Data.Nat using ..."</p>

<p>The module Data.Nat has the following definitions:</p>

<p>data ℕ : Set where
  zero : ℕ
  suc  : (n : ℕ) → ℕ</p>

<p><em>+</em> : ℕ → ℕ → ℕ
zero  + m = m
suc n + m = suc (n + m)</p>

<p>Enter 'ℕ' with "\bN".</p>

<pre class="Agda">
<a id="plusTwoThree"></a><a id="19269" href="NahasTutorialModule.html#19269" class="Function">plusTwoThree</a> <a id="19282" class="Symbol">:</a> <a id="19284" class="Symbol">((</a><a id="19286" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="19290" class="Symbol">(</a><a id="19291" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="19295" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="19299" class="Symbol">))</a> <a id="19302" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="19304" class="Symbol">(</a><a id="19305" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="19309" class="Symbol">(</a><a id="19310" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="19314" class="Symbol">(</a><a id="19315" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="19319" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="19323" class="Symbol">))))</a> <a id="19328" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="19330" class="Symbol">(</a><a id="19331" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="19335" class="Symbol">(</a><a id="19336" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="19340" class="Symbol">(</a><a id="19341" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="19345" class="Symbol">(</a><a id="19346" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="19350" class="Symbol">(</a><a id="19351" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="19355" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="19359" class="Symbol">)))))</a>
<a id="19365" href="NahasTutorialModule.html#19269" class="Function">plusTwoThree</a> <a id="19378" class="Symbol">=</a> <a id="19380" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

</pre>

<p>The module also declares these types "built-in" with the line:
<br><code>{-# BUILTIN NATURAL ℕ #-}</code><br></p>

<p>That is important, because it means that numbers like "2" can be
interpreted as an ℕ and that Agda's compilers will perform operations
on ℕ in proofs.</p>

<pre class="Agda">
<a id="plusTwoThreeAgain"></a><a id="19652" href="NahasTutorialModule.html#19652" class="Function">plusTwoThreeAgain</a> <a id="19670" class="Symbol">:</a> <a id="19672" class="Symbol">(</a> <a id="19674" class="Number">2</a> <a id="19676" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="19678" class="Number">3</a> <a id="19680" class="Symbol">)</a> <a id="19682" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="19684" class="Number">5</a>
<a id="19686" href="NahasTutorialModule.html#19652" class="Function">plusTwoThreeAgain</a> <a id="19704" class="Symbol">=</a> <a id="19706" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

</pre>

<p>Using "C-c C-t" I could see that the type of the goal was
<br><code>(suc (suc (suc (suc (suc zero))))) ≡ (suc (suc (suc (suc (suc zero)))))</code><br>
So, I entered "refl" and "C-c C-spacebar".  Agda must do simplification by execution.  </p>

<pre class="Agda">
<a id="plusZeroN"></a><a id="19955" href="NahasTutorialModule.html#19955" class="Function">plusZeroN</a> <a id="19965" class="Symbol">:</a> <a id="19967" class="Symbol">(</a><a id="19968" href="NahasTutorialModule.html#19968" class="Bound">n</a> <a id="19970" class="Symbol">:</a> <a id="19972" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="19973" class="Symbol">)</a> <a id="19975" class="Symbol">→</a> <a id="19977" class="Symbol">(</a> <a id="19979" class="Number">0</a> <a id="19981" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="19983" href="NahasTutorialModule.html#19968" class="Bound">n</a> <a id="19985" class="Symbol">)</a> <a id="19987" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="19989" href="NahasTutorialModule.html#19968" class="Bound">n</a>
<a id="19991" href="NahasTutorialModule.html#19955" class="Function">plusZeroN</a> <a id="20001" href="NahasTutorialModule.html#20001" class="Bound">n</a> <a id="20003" class="Symbol">=</a> <a id="20005" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

</pre>

<p>That's the simple one.  The next requires induction.</p>

<p>Induction in Agda is usually done using the congruence function, named
"cong".   We imported it when we imported the definition of <em>≡</em> above.</p>

<p>cong : ∀ {A B : Set} (f : A → B) {x y : A} → x ≡ y → f x ≡ f y
cong f refl = refl</p>

<pre class="Agda">
<a id="plusNZero"></a><a id="20305" href="NahasTutorialModule.html#20305" class="Function">plusNZero</a> <a id="20315" class="Symbol">:</a> <a id="20317" class="Symbol">(</a><a id="20318" href="NahasTutorialModule.html#20318" class="Bound">n</a> <a id="20320" class="Symbol">:</a> <a id="20322" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="20323" class="Symbol">)</a> <a id="20325" class="Symbol">→</a> <a id="20327" class="Symbol">(</a> <a id="20329" href="NahasTutorialModule.html#20318" class="Bound">n</a> <a id="20331" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="20333" class="Number">0</a> <a id="20335" class="Symbol">)</a> <a id="20337" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="20339" href="NahasTutorialModule.html#20318" class="Bound">n</a>
<a id="20341" href="NahasTutorialModule.html#20305" class="Function">plusNZero</a> <a id="20351" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="20356" class="Symbol">=</a> <a id="20358" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="20363" href="NahasTutorialModule.html#20305" class="Function">plusNZero</a> <a id="20373" class="Symbol">(</a><a id="20374" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="20378" href="NahasTutorialModule.html#20378" class="Bound">n′</a><a id="20380" class="Symbol">)</a> <a id="20382" class="Symbol">=</a> <a id="20384" href="Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="20389" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="20393" class="Symbol">(</a><a id="20394" href="NahasTutorialModule.html#20305" class="Function">plusNZero</a> <a id="20404" href="NahasTutorialModule.html#20378" class="Bound">n′</a><a id="20406" class="Symbol">)</a>

</pre>

<p>Obviously, the n=0 case is trivial, because it simplifies to 0=0.</p>

<p>The <code>n=(suc n′)</code> case is trying to prove <code>suc (n′ + 0) ≡ suc n′</code>.
Well, that's <code>(plusNZero n′)</code> with a "suc" on both sides of the equality.
So, we can construct that using the "cong" function with arguments
"suc" and <code>(plusNZero n′)</code>.  </p>

<p>The inductive case is usually (but I don't think always) written using
"cong".  The function definition does contain a recursive call to "plusNZero"
but its argument is not "n" but "n′".  Since "n′" is strictly smaller
than "n", the compiler can be sure that the recursive call is not part
of an infinite loop.</p>

<p>I'm not sure how it will work when the argument to the recursive call
is harder to determine to be smaller.</p>

<p>This is very different from Coq, where the induction hypothesis is
explicitly created when we do the "elim" command.  </p>

<p>Now, for the difficult proof: symmetry of addition.</p>

<p>First we import some operators used to prove a series of transitive
equalities.  Basically, they let you prove "a ≡ b" by a series of
small steps from "a" to "b". If Agda cannot figure out the step on its
own, you can provide the operations that make it possible.</p>

<p>This is not similar to Coq's "rewrite", because rewrite lets you work <em>inside</em> a term. </p>

<pre class="Agda">
<a id="21678" class="Comment">-- uses this import from above: import Relation.Binary.PropositionalEquality as Eq</a>
<a id="21761" class="Keyword">open</a> <a id="21766" href="Relation.Binary.PropositionalEquality.Core.html#2499" class="Module">Eq.≡-Reasoning</a> <a id="21781" class="Keyword">using</a> <a id="21787" class="Symbol">(</a><a id="21788" href="Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin_</a><a id="21794" class="Symbol">;</a> <a id="21796" href="Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">_≡⟨⟩_</a><a id="21801" class="Symbol">;</a> <a id="21803" href="Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">_≡⟨_⟩_</a><a id="21809" class="Symbol">;</a> <a id="21811" href="Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">_∎</a><a id="21813" class="Symbol">)</a>

<a id="exampleOfEqReasoning"></a><a id="21816" href="NahasTutorialModule.html#21816" class="Function">exampleOfEqReasoning</a> <a id="21837" class="Symbol">:</a> <a id="21839" class="Symbol">(</a> <a id="21841" class="Number">2</a> <a id="21843" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="21845" class="Number">3</a> <a id="21847" class="Symbol">)</a> <a id="21849" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="21851" class="Number">5</a>
<a id="21853" href="NahasTutorialModule.html#21816" class="Function">exampleOfEqReasoning</a> <a id="21874" class="Symbol">=</a> <a id="21876" href="Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
  <a id="21884" class="Number">2</a> <a id="21886" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="21888" class="Number">3</a>  <a id="21891" class="Comment">{- left hand of what we&#39;re trying to prove -}</a>
  <a id="21939" href="Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>   
  <a id="21948" class="Symbol">((</a><a id="21950" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="21954" class="Symbol">(</a><a id="21955" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="21959" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="21963" class="Symbol">))</a> <a id="21966" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="21968" class="Symbol">(</a><a id="21969" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="21973" class="Symbol">(</a><a id="21974" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="21978" class="Symbol">(</a><a id="21979" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="21983" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="21987" class="Symbol">))))</a>  <a id="21993" class="Comment">{- first step -}</a>
  <a id="22012" href="Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="22015" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="22020" href="Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a> <a id="22022" class="Comment">{- reason for second step is &quot;refl&quot;, but really isn&#39;t needed -}</a>
    <a id="22090" class="Symbol">(</a><a id="22091" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22095" class="Symbol">((</a><a id="22097" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22101" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="22105" class="Symbol">)</a> <a id="22107" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="22109" class="Symbol">(</a><a id="22110" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22114" class="Symbol">(</a><a id="22115" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22119" class="Symbol">(</a><a id="22120" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22124" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="22128" class="Symbol">)))))</a> <a id="22134" class="Comment">{- second step -}</a>
  <a id="22154" href="Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
    <a id="22162" class="Symbol">(</a><a id="22163" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22167" class="Symbol">(</a><a id="22168" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22172" class="Symbol">(</a><a id="22173" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="22178" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="22180" class="Symbol">(</a><a id="22181" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22185" class="Symbol">(</a><a id="22186" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22190" class="Symbol">(</a><a id="22191" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22195" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="22199" class="Symbol">))))))</a> <a id="22206" class="Comment">{- third step -}</a>
  <a id="22225" href="Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
    <a id="22233" class="Symbol">(</a><a id="22234" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22238" class="Symbol">(</a><a id="22239" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22243" class="Symbol">(</a><a id="22244" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22248" class="Symbol">(</a><a id="22249" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22253" class="Symbol">(</a><a id="22254" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22258" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="22262" class="Symbol">)))))</a> <a id="22268" class="Comment">{- fourth step -}</a>
  <a id="22288" href="Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
    <a id="22296" class="Number">5</a> <a id="22298" class="Comment">{- right side of what we&#39;re trying to prove -}</a>
  <a id="22347" href="Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre>

<p>Enter '⟨' with "\&lt;".
Enter '⟩' with ">".
Enter '∎' with "\qed".</p>

<p>Next we prove a simple helper function.</p>

<pre class="Agda">
<a id="plusSymmetricHelper"></a><a id="22470" href="NahasTutorialModule.html#22470" class="Function">plusSymmetricHelper</a> <a id="22490" class="Symbol">:</a> <a id="22492" class="Symbol">(</a><a id="22493" href="NahasTutorialModule.html#22493" class="Bound">n</a> <a id="22495" href="NahasTutorialModule.html#22495" class="Bound">m</a> <a id="22497" class="Symbol">:</a> <a id="22499" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="22500" class="Symbol">)</a> <a id="22502" class="Symbol">→</a> <a id="22504" class="Symbol">(</a> <a id="22506" href="NahasTutorialModule.html#22493" class="Bound">n</a> <a id="22508" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="22510" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22514" href="NahasTutorialModule.html#22495" class="Bound">m</a> <a id="22516" class="Symbol">)</a> <a id="22518" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="22520" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22524" class="Symbol">(</a> <a id="22526" href="NahasTutorialModule.html#22493" class="Bound">n</a> <a id="22528" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="22530" href="NahasTutorialModule.html#22495" class="Bound">m</a> <a id="22532" class="Symbol">)</a>
<a id="22534" href="NahasTutorialModule.html#22470" class="Function">plusSymmetricHelper</a> <a id="22554" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="22559" href="NahasTutorialModule.html#22559" class="Bound">m</a> <a id="22561" class="Symbol">=</a> <a id="22563" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="22568" href="NahasTutorialModule.html#22470" class="Function">plusSymmetricHelper</a> <a id="22588" class="Symbol">(</a><a id="22589" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22593" href="NahasTutorialModule.html#22593" class="Bound">n′</a><a id="22595" class="Symbol">)</a> <a id="22597" href="NahasTutorialModule.html#22597" class="Bound">m</a> <a id="22599" class="Symbol">=</a> <a id="22601" href="Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="22606" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22610" class="Symbol">(</a><a id="22611" href="NahasTutorialModule.html#22470" class="Function">plusSymmetricHelper</a> <a id="22631" href="NahasTutorialModule.html#22593" class="Bound">n′</a> <a id="22634" href="NahasTutorialModule.html#22597" class="Bound">m</a><a id="22635" class="Symbol">)</a>

</pre>

<p>Lastly, the big theorem itself:</p>

<pre class="Agda">
<a id="plusSymmetric"></a><a id="22685" href="NahasTutorialModule.html#22685" class="Function">plusSymmetric</a> <a id="22699" class="Symbol">:</a> <a id="22701" class="Symbol">(</a><a id="22702" href="NahasTutorialModule.html#22702" class="Bound">n</a> <a id="22704" href="NahasTutorialModule.html#22704" class="Bound">m</a> <a id="22706" class="Symbol">:</a> <a id="22708" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a><a id="22709" class="Symbol">)</a> <a id="22711" class="Symbol">→</a> <a id="22713" class="Symbol">(</a> <a id="22715" href="NahasTutorialModule.html#22702" class="Bound">n</a> <a id="22717" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="22719" href="NahasTutorialModule.html#22704" class="Bound">m</a> <a id="22721" class="Symbol">)</a> <a id="22723" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="22725" class="Symbol">(</a><a id="22726" href="NahasTutorialModule.html#22704" class="Bound">m</a> <a id="22728" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="22730" href="NahasTutorialModule.html#22702" class="Bound">n</a><a id="22731" class="Symbol">)</a>
<a id="22733" href="NahasTutorialModule.html#22685" class="Function">plusSymmetric</a> <a id="22747" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="22752" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="22757" class="Symbol">=</a> <a id="22759" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="22764" href="NahasTutorialModule.html#22685" class="Function">plusSymmetric</a> <a id="22778" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="22783" class="Symbol">(</a><a id="22784" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22788" href="NahasTutorialModule.html#22788" class="Bound">m′</a><a id="22790" class="Symbol">)</a> <a id="22792" class="Symbol">=</a> <a id="22794" href="Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="22799" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22803" class="Symbol">(</a><a id="22804" href="NahasTutorialModule.html#17000" class="Function">equalityIsSymmetric</a> <a id="22824" class="Symbol">(</a><a id="22825" href="NahasTutorialModule.html#20305" class="Function">plusNZero</a> <a id="22835" href="NahasTutorialModule.html#22788" class="Bound">m′</a><a id="22837" class="Symbol">))</a>
<a id="22840" href="NahasTutorialModule.html#22685" class="Function">plusSymmetric</a> <a id="22854" class="Symbol">(</a><a id="22855" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22859" href="NahasTutorialModule.html#22859" class="Bound">n′</a><a id="22861" class="Symbol">)</a> <a id="22863" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a> <a id="22868" class="Symbol">=</a> <a id="22870" href="Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="22875" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22879" class="Symbol">(</a><a id="22880" href="NahasTutorialModule.html#20305" class="Function">plusNZero</a> <a id="22890" href="NahasTutorialModule.html#22859" class="Bound">n′</a><a id="22892" class="Symbol">)</a>
<a id="22894" href="NahasTutorialModule.html#22685" class="Function">plusSymmetric</a> <a id="22908" class="Symbol">(</a><a id="22909" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22913" href="NahasTutorialModule.html#22913" class="Bound">n′</a><a id="22915" class="Symbol">)</a> <a id="22917" class="Symbol">(</a><a id="22918" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22922" href="NahasTutorialModule.html#22922" class="Bound">m′</a><a id="22924" class="Symbol">)</a> <a id="22926" class="Symbol">=</a> <a id="22928" href="Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="22933" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22937" class="Symbol">(</a><a id="22938" href="Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
  <a id="22946" href="NahasTutorialModule.html#22913" class="Bound">n′</a> <a id="22949" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="22951" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22955" href="NahasTutorialModule.html#22922" class="Bound">m′</a> 
  <a id="22961" href="Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="22964" href="NahasTutorialModule.html#22470" class="Function">plusSymmetricHelper</a> <a id="22984" href="NahasTutorialModule.html#22913" class="Bound">n′</a> <a id="22987" href="NahasTutorialModule.html#22922" class="Bound">m′</a> <a id="22990" href="Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
  <a id="22994" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="22998" class="Symbol">(</a><a id="22999" href="NahasTutorialModule.html#22913" class="Bound">n′</a> <a id="23002" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="23004" href="NahasTutorialModule.html#22922" class="Bound">m′</a><a id="23006" class="Symbol">)</a>
  <a id="23010" href="Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="23013" href="Relation.Binary.PropositionalEquality.Core.html#1090" class="Function">cong</a> <a id="23018" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="23022" class="Symbol">(</a><a id="23023" href="NahasTutorialModule.html#22685" class="Function">plusSymmetric</a> <a id="23037" href="NahasTutorialModule.html#22913" class="Bound">n′</a> <a id="23040" href="NahasTutorialModule.html#22922" class="Bound">m′</a><a id="23042" class="Symbol">)</a> <a id="23044" href="Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
  <a id="23048" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="23052" class="Symbol">(</a><a id="23053" href="NahasTutorialModule.html#22922" class="Bound">m′</a> <a id="23056" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="23058" href="NahasTutorialModule.html#22913" class="Bound">n′</a><a id="23060" class="Symbol">)</a>
  <a id="23064" href="Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">≡⟨</a> <a id="23067" href="NahasTutorialModule.html#17000" class="Function">equalityIsSymmetric</a> <a id="23087" class="Symbol">(</a><a id="23088" href="NahasTutorialModule.html#22470" class="Function">plusSymmetricHelper</a> <a id="23108" href="NahasTutorialModule.html#22922" class="Bound">m′</a> <a id="23111" href="NahasTutorialModule.html#22913" class="Bound">n′</a><a id="23113" class="Symbol">)</a> <a id="23115" href="Relation.Binary.PropositionalEquality.Core.html#2714" class="Function Operator">⟩</a>
    <a id="23121" href="NahasTutorialModule.html#22922" class="Bound">m′</a> <a id="23124" href="Agda.Builtin.Nat.html#298" class="Primitive Operator">+</a> <a id="23126" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="23130" href="NahasTutorialModule.html#22913" class="Bound">n′</a>
  <a id="23135" href="Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a><a id="23136" class="Symbol">)</a>

</pre>

<p>The induction is done in the recursive call <br><code>≡⟨ cong suc
(plusSymmetric n′ m′) ⟩</code><br> Agda's equality reasoning is different
from Coq's.  Coq's "rewrite" command lets us change a value inside an
equation.  Agda only lets us show a chain of equal statements without
substitution inside the equations.  In Agda, if we want to do
substitution inside an equation, we need to use "cong".  Basically,
cong's second argument is the equality we want to substitute and
cong's first argument is a function that wraps that equality with the
rest of the statement we want to substitute it into.</p>

<h2>Data Types</h2>

<p>We're going to be playing with Lists, so let's import Agda's list type.</p>

<pre class="Agda">
<a id="23829" class="Comment">--open import Data.List using (List ; []; _∷_)</a>

<a id="23877" class="Comment">--!!! I could not get official version to work.  I had to rename</a>
<a id="23942" class="Comment">-- &quot;_::_&quot; as &quot;cons&quot; to get it to work.</a>
<a id="23981" class="Keyword">data</a> <a id="List"></a><a id="23986" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="23991" class="Symbol">(</a><a id="23992" href="NahasTutorialModule.html#23992" class="Bound">A</a> <a id="23994" class="Symbol">:</a> <a id="23996" class="PrimitiveType">Set</a><a id="23999" class="Symbol">)</a> <a id="24001" class="Symbol">:</a> <a id="24003" class="PrimitiveType">Set</a> <a id="24007" class="Keyword">where</a>
  <a id="List.[]"></a><a id="24015" href="NahasTutorialModule.html#24015" class="InductiveConstructor">[]</a>  <a id="24019" class="Symbol">:</a> <a id="24021" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="24026" href="NahasTutorialModule.html#23992" class="Bound">A</a>
  <a id="List.cons"></a><a id="24030" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="24035" class="Symbol">:</a> <a id="24037" class="Symbol">(</a><a id="24038" href="NahasTutorialModule.html#24038" class="Bound">x</a> <a id="24040" class="Symbol">:</a> <a id="24042" href="NahasTutorialModule.html#23992" class="Bound">A</a><a id="24043" class="Symbol">)</a> <a id="24045" class="Symbol">(</a><a id="24046" href="NahasTutorialModule.html#24046" class="Bound">xs</a> <a id="24049" class="Symbol">:</a> <a id="24051" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="24056" href="NahasTutorialModule.html#23992" class="Bound">A</a><a id="24057" class="Symbol">)</a> <a id="24059" class="Symbol">→</a> <a id="24061" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="24066" href="NahasTutorialModule.html#23992" class="Bound">A</a>

</pre>

<p>The official version has the definition:</p>

<p>data List (A : Set) : Set where
  []  : List A
  <em>∷</em> : (x : A) (xs : List A) → List A</p>

<p>So an instance of (List ℕ) might be "3 :: 2 :: 1 :: []".</p>

<pre class="Agda">
<a id="length"></a><a id="24270" href="NahasTutorialModule.html#24270" class="Function">length</a> <a id="24277" class="Symbol">:</a> <a id="24279" class="Symbol">{</a><a id="24280" href="NahasTutorialModule.html#24280" class="Bound">A</a> <a id="24282" class="Symbol">:</a> <a id="24284" class="PrimitiveType">Set</a><a id="24287" class="Symbol">}</a> <a id="24289" class="Symbol">→</a> <a id="24291" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="24296" href="NahasTutorialModule.html#24280" class="Bound">A</a> <a id="24298" class="Symbol">→</a> <a id="24300" href="Agda.Builtin.Nat.html#165" class="Datatype">ℕ</a>
<a id="24302" href="NahasTutorialModule.html#24270" class="Function">length</a> <a id="24309" href="NahasTutorialModule.html#24015" class="InductiveConstructor">[]</a> <a id="24312" class="Symbol">=</a> <a id="24314" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a>
<a id="24319" href="NahasTutorialModule.html#24270" class="Function">length</a> <a id="24326" class="Symbol">(</a><a id="24327" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="24332" href="NahasTutorialModule.html#24332" class="Bound">a</a> <a id="24334" href="NahasTutorialModule.html#24334" class="Bound">as</a><a id="24336" class="Symbol">)</a> <a id="24338" class="Symbol">=</a> <a id="24340" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="24344" class="Symbol">(</a><a id="24345" href="NahasTutorialModule.html#24270" class="Function">length</a> <a id="24352" href="NahasTutorialModule.html#24334" class="Bound">as</a><a id="24354" class="Symbol">)</a>

</pre>

<p>And the proof that adding an element increases a list's length by 1.</p>

<pre class="Agda">
<a id="24441" class="Comment">-- TODO: I only got Agda to accept the following by renaming &quot;_::_&quot; as &quot;cons&quot;</a>
<a id="consAddsOneToLength"></a><a id="24519" href="NahasTutorialModule.html#24519" class="Function">consAddsOneToLength</a> <a id="24539" class="Symbol">:</a> <a id="24541" class="Symbol">{</a><a id="24542" href="NahasTutorialModule.html#24542" class="Bound">A</a> <a id="24544" class="Symbol">:</a> <a id="24546" class="PrimitiveType">Set</a><a id="24549" class="Symbol">}</a> <a id="24551" class="Symbol">→</a> <a id="24553" class="Symbol">(</a><a id="24554" href="NahasTutorialModule.html#24554" class="Bound">a</a> <a id="24556" class="Symbol">:</a> <a id="24558" href="NahasTutorialModule.html#24542" class="Bound">A</a><a id="24559" class="Symbol">)</a> <a id="24561" class="Symbol">→</a> <a id="24563" class="Symbol">(</a><a id="24564" href="NahasTutorialModule.html#24564" class="Bound">as</a> <a id="24567" class="Symbol">:</a> <a id="24569" class="Symbol">(</a><a id="24570" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="24575" href="NahasTutorialModule.html#24542" class="Bound">A</a><a id="24576" class="Symbol">))</a> <a id="24579" class="Symbol">→</a> <a id="24581" class="Symbol">((</a><a id="24583" href="NahasTutorialModule.html#24270" class="Function">length</a> <a id="24590" class="Symbol">(</a><a id="24591" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="24596" href="NahasTutorialModule.html#24554" class="Bound">a</a> <a id="24598" href="NahasTutorialModule.html#24564" class="Bound">as</a><a id="24600" class="Symbol">))</a> <a id="24603" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="24605" class="Symbol">(</a><a id="24606" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a> <a id="24610" class="Symbol">(</a><a id="24611" href="NahasTutorialModule.html#24270" class="Function">length</a> <a id="24618" href="NahasTutorialModule.html#24564" class="Bound">as</a><a id="24620" class="Symbol">)))</a>
<a id="24624" href="NahasTutorialModule.html#24519" class="Function">consAddsOneToLength</a> <a id="24644" href="NahasTutorialModule.html#24644" class="Bound">a</a> <a id="24646" href="NahasTutorialModule.html#24646" class="Bound">as</a> <a id="24649" class="Symbol">=</a> <a id="24651" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

</pre>

<p>Now the three versions of head.</p>

<pre class="Agda">
<a id="head1"></a><a id="24704" href="NahasTutorialModule.html#24704" class="Function">head1</a> <a id="24710" class="Symbol">:</a> <a id="24712" class="Symbol">{</a><a id="24713" href="NahasTutorialModule.html#24713" class="Bound">A</a> <a id="24715" class="Symbol">:</a> <a id="24717" class="PrimitiveType">Set</a><a id="24720" class="Symbol">}</a> <a id="24722" class="Symbol">→</a> <a id="24724" class="Symbol">(</a><a id="24725" href="NahasTutorialModule.html#24725" class="Bound">default</a> <a id="24733" class="Symbol">:</a> <a id="24735" href="NahasTutorialModule.html#24713" class="Bound">A</a><a id="24736" class="Symbol">)</a> <a id="24738" class="Symbol">→</a> <a id="24740" class="Symbol">(</a><a id="24741" href="NahasTutorialModule.html#24741" class="Bound">as</a> <a id="24744" class="Symbol">:</a> <a id="24746" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="24751" href="NahasTutorialModule.html#24713" class="Bound">A</a><a id="24752" class="Symbol">)</a> <a id="24754" class="Symbol">→</a> <a id="24756" href="NahasTutorialModule.html#24713" class="Bound">A</a>
<a id="24758" href="NahasTutorialModule.html#24704" class="Function">head1</a> <a id="24764" href="NahasTutorialModule.html#24764" class="Bound">default</a> <a id="24772" href="NahasTutorialModule.html#24015" class="InductiveConstructor">[]</a> <a id="24775" class="Symbol">=</a> <a id="24777" href="NahasTutorialModule.html#24764" class="Bound">default</a>
<a id="24785" href="NahasTutorialModule.html#24704" class="Function">head1</a> <a id="24791" href="NahasTutorialModule.html#24791" class="Bound">default</a> <a id="24799" class="Symbol">(</a><a id="24800" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="24805" href="NahasTutorialModule.html#24805" class="Bound">a</a> <a id="24807" href="NahasTutorialModule.html#24807" class="Bound">as</a><a id="24809" class="Symbol">)</a> <a id="24811" class="Symbol">=</a> <a id="24813" href="NahasTutorialModule.html#24805" class="Bound">a</a>

<a id="head1Correct"></a><a id="24816" href="NahasTutorialModule.html#24816" class="Function">head1Correct</a> <a id="24829" class="Symbol">:</a> <a id="24831" class="Symbol">{</a><a id="24832" href="NahasTutorialModule.html#24832" class="Bound">A</a> <a id="24834" class="Symbol">:</a> <a id="24836" class="PrimitiveType">Set</a><a id="24839" class="Symbol">}</a> <a id="24841" class="Symbol">→</a> <a id="24843" class="Symbol">(</a><a id="24844" href="NahasTutorialModule.html#24844" class="Bound">default</a> <a id="24852" class="Symbol">:</a> <a id="24854" href="NahasTutorialModule.html#24832" class="Bound">A</a><a id="24855" class="Symbol">)</a> <a id="24857" class="Symbol">→</a> <a id="24859" class="Symbol">(</a><a id="24860" href="NahasTutorialModule.html#24860" class="Bound">a</a> <a id="24862" class="Symbol">:</a> <a id="24864" href="NahasTutorialModule.html#24832" class="Bound">A</a><a id="24865" class="Symbol">)</a> <a id="24867" class="Symbol">→</a> <a id="24869" class="Symbol">(</a><a id="24870" href="NahasTutorialModule.html#24870" class="Bound">as</a> <a id="24873" class="Symbol">:</a> <a id="24875" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="24880" href="NahasTutorialModule.html#24832" class="Bound">A</a><a id="24881" class="Symbol">)</a> <a id="24883" class="Symbol">→</a> <a id="24885" class="Symbol">(((</a><a id="24888" href="NahasTutorialModule.html#24704" class="Function">head1</a> <a id="24894" href="NahasTutorialModule.html#24844" class="Bound">default</a> <a id="24902" href="NahasTutorialModule.html#24015" class="InductiveConstructor">[]</a><a id="24904" class="Symbol">)</a> <a id="24906" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="24908" href="NahasTutorialModule.html#24844" class="Bound">default</a><a id="24915" class="Symbol">)</a> <a id="24917" href="NahasTutorialModule.html#12356" class="Datatype Operator">×</a> <a id="24919" class="Symbol">((</a><a id="24921" href="NahasTutorialModule.html#24704" class="Function">head1</a> <a id="24927" href="NahasTutorialModule.html#24844" class="Bound">default</a> <a id="24935" class="Symbol">(</a><a id="24936" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="24941" href="NahasTutorialModule.html#24860" class="Bound">a</a> <a id="24943" href="NahasTutorialModule.html#24870" class="Bound">as</a><a id="24945" class="Symbol">))</a> <a id="24948" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="24950" href="NahasTutorialModule.html#24860" class="Bound">a</a><a id="24951" class="Symbol">))</a>
<a id="24954" href="NahasTutorialModule.html#24816" class="Function">head1Correct</a> <a id="24967" href="NahasTutorialModule.html#24967" class="Bound">default</a> <a id="24975" href="NahasTutorialModule.html#24975" class="Bound">a</a> <a id="24977" href="NahasTutorialModule.html#24977" class="Bound">as</a> <a id="24980" class="Symbol">=</a> <a id="24982" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="24987" href="NahasTutorialModule.html#12386" class="InductiveConstructor Operator">,′</a> <a id="24990" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>



<a id="24998" class="Keyword">data</a> <a id="Maybe"></a><a id="25003" href="NahasTutorialModule.html#25003" class="Datatype">Maybe</a> <a id="25009" class="Symbol">(</a><a id="25010" href="NahasTutorialModule.html#25010" class="Bound">A</a> <a id="25012" class="Symbol">:</a> <a id="25014" class="PrimitiveType">Set</a><a id="25017" class="Symbol">)</a> <a id="25019" class="Symbol">:</a> <a id="25021" class="PrimitiveType">Set</a> <a id="25025" class="Keyword">where</a>
  <a id="Maybe.nothing"></a><a id="25033" href="NahasTutorialModule.html#25033" class="InductiveConstructor">nothing</a> <a id="25041" class="Symbol">:</a> <a id="25043" href="NahasTutorialModule.html#25003" class="Datatype">Maybe</a> <a id="25049" href="NahasTutorialModule.html#25010" class="Bound">A</a>
  <a id="Maybe.just"></a><a id="25053" href="NahasTutorialModule.html#25053" class="InductiveConstructor">just</a>    <a id="25061" class="Symbol">:</a> <a id="25063" href="NahasTutorialModule.html#25010" class="Bound">A</a> <a id="25065" class="Symbol">→</a> <a id="25067" href="NahasTutorialModule.html#25003" class="Datatype">Maybe</a> <a id="25073" href="NahasTutorialModule.html#25010" class="Bound">A</a>

<a id="head2"></a><a id="25076" href="NahasTutorialModule.html#25076" class="Function">head2</a> <a id="25082" class="Symbol">:</a> <a id="25084" class="Symbol">{</a><a id="25085" href="NahasTutorialModule.html#25085" class="Bound">A</a> <a id="25087" class="Symbol">:</a> <a id="25089" class="PrimitiveType">Set</a><a id="25092" class="Symbol">}</a> <a id="25094" class="Symbol">→</a> <a id="25096" class="Symbol">(</a><a id="25097" href="NahasTutorialModule.html#25097" class="Bound">as</a> <a id="25100" class="Symbol">:</a> <a id="25102" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="25107" href="NahasTutorialModule.html#25085" class="Bound">A</a><a id="25108" class="Symbol">)</a> <a id="25110" class="Symbol">→</a> <a id="25112" href="NahasTutorialModule.html#25003" class="Datatype">Maybe</a> <a id="25118" href="NahasTutorialModule.html#25085" class="Bound">A</a>
<a id="25120" href="NahasTutorialModule.html#25076" class="Function">head2</a> <a id="25126" href="NahasTutorialModule.html#24015" class="InductiveConstructor">[]</a> <a id="25129" class="Symbol">=</a> <a id="25131" href="NahasTutorialModule.html#25033" class="InductiveConstructor">nothing</a>
<a id="25139" href="NahasTutorialModule.html#25076" class="Function">head2</a> <a id="25145" class="Symbol">(</a><a id="25146" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="25151" href="NahasTutorialModule.html#25151" class="Bound">x</a> <a id="25153" href="NahasTutorialModule.html#25153" class="Bound">as</a><a id="25155" class="Symbol">)</a> <a id="25157" class="Symbol">=</a> <a id="25159" href="NahasTutorialModule.html#25053" class="InductiveConstructor">just</a> <a id="25164" href="NahasTutorialModule.html#25151" class="Bound">x</a>

<a id="head2Correct"></a><a id="25167" href="NahasTutorialModule.html#25167" class="Function">head2Correct</a> <a id="25180" class="Symbol">:</a> <a id="25182" class="Symbol">{</a><a id="25183" href="NahasTutorialModule.html#25183" class="Bound">A</a> <a id="25185" class="Symbol">:</a> <a id="25187" class="PrimitiveType">Set</a><a id="25190" class="Symbol">}</a> <a id="25192" class="Symbol">→</a> <a id="25194" class="Symbol">(</a><a id="25195" href="NahasTutorialModule.html#25195" class="Bound">a</a> <a id="25197" class="Symbol">:</a> <a id="25199" href="NahasTutorialModule.html#25183" class="Bound">A</a><a id="25200" class="Symbol">)</a> <a id="25202" class="Symbol">→</a> <a id="25204" class="Symbol">(</a><a id="25205" href="NahasTutorialModule.html#25205" class="Bound">as</a> <a id="25208" class="Symbol">:</a> <a id="25210" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="25215" href="NahasTutorialModule.html#25183" class="Bound">A</a><a id="25216" class="Symbol">)</a> <a id="25218" class="Symbol">→</a> <a id="25220" class="Symbol">(((</a><a id="25223" href="NahasTutorialModule.html#25076" class="Function">head2</a> <a id="25229" class="Symbol">{</a><a id="25230" href="NahasTutorialModule.html#25183" class="Bound">A</a><a id="25231" class="Symbol">}</a> <a id="25233" href="NahasTutorialModule.html#24015" class="InductiveConstructor">[]</a><a id="25235" class="Symbol">)</a> <a id="25237" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="25239" href="NahasTutorialModule.html#25033" class="InductiveConstructor">nothing</a> <a id="25247" class="Symbol">)</a> <a id="25249" href="NahasTutorialModule.html#12356" class="Datatype Operator">×</a> <a id="25251" class="Symbol">((</a><a id="25253" href="NahasTutorialModule.html#25076" class="Function">head2</a> <a id="25259" class="Symbol">(</a><a id="25260" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="25265" href="NahasTutorialModule.html#25195" class="Bound">a</a> <a id="25267" href="NahasTutorialModule.html#25205" class="Bound">as</a><a id="25269" class="Symbol">))</a> <a id="25272" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="25274" href="NahasTutorialModule.html#25053" class="InductiveConstructor">just</a> <a id="25279" href="NahasTutorialModule.html#25195" class="Bound">a</a><a id="25280" class="Symbol">))</a>
<a id="25283" href="NahasTutorialModule.html#25167" class="Function">head2Correct</a> <a id="25296" href="NahasTutorialModule.html#25296" class="Bound">a</a> <a id="25298" href="NahasTutorialModule.html#25298" class="Bound">as</a> <a id="25301" class="Symbol">=</a> <a id="25303" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="25308" href="NahasTutorialModule.html#12386" class="InductiveConstructor Operator">,′</a> <a id="25311" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

</pre>

<p>NOTE: Needed to pass Set A to head2 on an empty list to determine the type of the list.  That was done using "{}" to pass the implicit argument in an explicit fashion.</p>

<pre class="Agda">
<a id="head3"></a><a id="25500" href="NahasTutorialModule.html#25500" class="Function">head3</a> <a id="25506" class="Symbol">:</a> <a id="25508" class="Symbol">{</a><a id="25509" href="NahasTutorialModule.html#25509" class="Bound">A</a> <a id="25511" class="Symbol">:</a> <a id="25513" class="PrimitiveType">Set</a><a id="25516" class="Symbol">}</a> <a id="25518" class="Symbol">→</a> <a id="25520" class="Symbol">(</a><a id="25521" href="NahasTutorialModule.html#25521" class="Bound">as</a> <a id="25524" class="Symbol">:</a> <a id="25526" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="25531" href="NahasTutorialModule.html#25509" class="Bound">A</a><a id="25532" class="Symbol">)</a> <a id="25534" class="Symbol">→</a> <a id="25536" class="Symbol">(</a><a id="25537" href="NahasTutorialModule.html#25537" class="Bound">as</a> <a id="25540" class="Symbol">:</a> <a id="25542" class="Symbol">(</a><a id="25543" href="NahasTutorialModule.html#25521" class="Bound">as</a> <a id="25546" href="NahasTutorialModule.html#18290" class="Function Operator">≢</a> <a id="25548" href="NahasTutorialModule.html#24015" class="InductiveConstructor">[]</a><a id="25550" class="Symbol">))</a> <a id="25553" class="Symbol">→</a> <a id="25555" href="NahasTutorialModule.html#25509" class="Bound">A</a>
<a id="25557" href="NahasTutorialModule.html#25500" class="Function">head3</a> <a id="25563" class="Symbol">{</a><a id="25564" href="NahasTutorialModule.html#25564" class="Bound">A</a><a id="25565" class="Symbol">}</a> <a id="25567" href="NahasTutorialModule.html#24015" class="InductiveConstructor">[]</a> <a id="25570" href="NahasTutorialModule.html#25570" class="Bound">as≢empty</a> <a id="25579" class="Symbol">=</a> <a id="25581" href="NahasTutorialModule.html#9849" class="Function">absurdHelper</a> <a id="25594" href="NahasTutorialModule.html#25564" class="Bound">A</a> <a id="25596" class="Symbol">(</a><a id="25597" href="NahasTutorialModule.html#25570" class="Bound">as≢empty</a> <a id="25606" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="25610" class="Symbol">)</a>
<a id="25612" href="NahasTutorialModule.html#25500" class="Function">head3</a> <a id="25618" class="Symbol">{</a><a id="25619" href="NahasTutorialModule.html#25619" class="Bound">A</a><a id="25620" class="Symbol">}</a> <a id="25622" class="Symbol">(</a><a id="25623" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="25628" href="NahasTutorialModule.html#25628" class="Bound">a</a> <a id="25630" href="NahasTutorialModule.html#25630" class="Bound">as′</a><a id="25633" class="Symbol">)</a> <a id="25635" href="NahasTutorialModule.html#25635" class="Bound">as≢empty</a> <a id="25644" class="Symbol">=</a> <a id="25646" href="NahasTutorialModule.html#25628" class="Bound">a</a>

<a id="consNeverEmpty"></a><a id="25649" href="NahasTutorialModule.html#25649" class="Function">consNeverEmpty</a> <a id="25664" class="Symbol">:</a> <a id="25666" class="Symbol">{</a><a id="25667" href="NahasTutorialModule.html#25667" class="Bound">A</a> <a id="25669" class="Symbol">:</a> <a id="25671" class="PrimitiveType">Set</a><a id="25674" class="Symbol">}</a> <a id="25676" class="Symbol">→</a> <a id="25678" class="Symbol">(</a><a id="25679" href="NahasTutorialModule.html#25679" class="Bound">a</a> <a id="25681" class="Symbol">:</a> <a id="25683" href="NahasTutorialModule.html#25667" class="Bound">A</a><a id="25684" class="Symbol">)</a> <a id="25686" class="Symbol">→</a> <a id="25688" class="Symbol">(</a><a id="25689" href="NahasTutorialModule.html#25689" class="Bound">as</a> <a id="25692" class="Symbol">:</a> <a id="25694" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="25699" href="NahasTutorialModule.html#25667" class="Bound">A</a><a id="25700" class="Symbol">)</a> <a id="25702" class="Symbol">→</a> <a id="25704" class="Symbol">((</a><a id="25706" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="25711" href="NahasTutorialModule.html#25679" class="Bound">a</a> <a id="25713" href="NahasTutorialModule.html#25689" class="Bound">as</a><a id="25715" class="Symbol">)</a> <a id="25717" href="NahasTutorialModule.html#18290" class="Function Operator">≢</a> <a id="25719" href="NahasTutorialModule.html#24015" class="InductiveConstructor">[]</a><a id="25721" class="Symbol">)</a>
<a id="25723" href="NahasTutorialModule.html#25649" class="Function">consNeverEmpty</a> <a id="25738" href="NahasTutorialModule.html#25738" class="Bound">a</a> <a id="25740" href="NahasTutorialModule.html#25740" class="Bound">as</a> <a id="25743" class="Symbol">()</a>

<a id="25747" class="Comment">--head3Correct : {A : Set} → (a : A) → (as : List A) → ∃ (\ (safetyproof : ((cons a as) ≢ [])) → ((head3 (cons a as) safetyproof) ≡ a))</a>
<a id="25883" class="Comment">--head3Correct : {A : Set} → (a : A) → (as : List A) → ( Σ ((cons a as) ≢ []) (\ safetyproof → ((head3 (cons a as) safetyproof) ≡ a)) )</a>
<a id="head3Correct"></a><a id="26019" href="NahasTutorialModule.html#26019" class="Function">head3Correct</a> <a id="26032" class="Symbol">:</a> <a id="26034" class="Symbol">{</a><a id="26035" href="NahasTutorialModule.html#26035" class="Bound">A</a> <a id="26037" class="Symbol">:</a> <a id="26039" class="PrimitiveType">Set</a><a id="26042" class="Symbol">}</a> <a id="26044" class="Symbol">→</a> <a id="26046" class="Symbol">(</a><a id="26047" href="NahasTutorialModule.html#26047" class="Bound">a</a> <a id="26049" class="Symbol">:</a> <a id="26051" href="NahasTutorialModule.html#26035" class="Bound">A</a><a id="26052" class="Symbol">)</a> <a id="26054" class="Symbol">→</a> <a id="26056" class="Symbol">(</a><a id="26057" href="NahasTutorialModule.html#26057" class="Bound">as</a> <a id="26060" class="Symbol">:</a> <a id="26062" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="26067" href="NahasTutorialModule.html#26035" class="Bound">A</a><a id="26068" class="Symbol">)</a> <a id="26070" class="Symbol">→</a> <a id="26072" href="NahasTutorialModule.html#14327" class="Record">[</a> <a id="26074" href="NahasTutorialModule.html#26074" class="Bound">safetyproof</a> <a id="26086" href="NahasTutorialModule.html#14327" class="Record">∈</a> <a id="26088" class="Symbol">(</a> <a id="26090" class="Symbol">(</a><a id="26091" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="26096" href="NahasTutorialModule.html#26047" class="Bound">a</a> <a id="26098" href="NahasTutorialModule.html#26057" class="Bound">as</a> <a id="26101" class="Symbol">)</a> <a id="26103" href="NahasTutorialModule.html#18290" class="Function Operator">≢</a> <a id="26105" class="Symbol">(</a> <a id="26107" href="NahasTutorialModule.html#24015" class="InductiveConstructor">[]</a> <a id="26110" class="Symbol">{</a><a id="26111" href="NahasTutorialModule.html#26035" class="Bound">A</a><a id="26112" class="Symbol">}</a> <a id="26114" class="Symbol">)</a> <a id="26116" class="Symbol">)</a> <a id="26118" href="NahasTutorialModule.html#14327" class="Record">]</a>  <a id="26121" class="Symbol">((</a><a id="26123" href="NahasTutorialModule.html#25500" class="Function">head3</a> <a id="26129" class="Symbol">(</a><a id="26130" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="26135" href="NahasTutorialModule.html#26047" class="Bound">a</a> <a id="26137" href="NahasTutorialModule.html#26057" class="Bound">as</a><a id="26139" class="Symbol">)</a> <a id="26141" href="NahasTutorialModule.html#26074" class="Bound">safetyproof</a><a id="26152" class="Symbol">)</a> <a id="26154" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="26156" href="NahasTutorialModule.html#26047" class="Bound">a</a><a id="26157" class="Symbol">)</a>
<a id="26159" href="NahasTutorialModule.html#26019" class="Function">head3Correct</a> <a id="26172" href="NahasTutorialModule.html#26172" class="Bound">a</a> <a id="26174" href="NahasTutorialModule.html#26174" class="Bound">as</a> <a id="26177" class="Symbol">=</a> <a id="26179" href="NahasTutorialModule.html#25649" class="Function">consNeverEmpty</a> <a id="26194" href="NahasTutorialModule.html#26172" class="Bound">a</a> <a id="26196" href="NahasTutorialModule.html#26174" class="Bound">as</a> <a id="26199" href="NahasTutorialModule.html#14379" class="InductiveConstructor Operator">,</a> <a id="26201" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

</pre>

<p>I had trouble understanding the error messages from Agda.  I forgot to add the argument "safetyproof" to the call to head3 and spent about 20 minutes trying to figure out what the problem was.   That's why there are 3 different version of exist here!</p>

<p>A final proof that cons-ing the head and tail of a list gets you back to the original list.</p>

<pre class="Agda">
<a id="tail1"></a><a id="26589" href="NahasTutorialModule.html#26589" class="Function">tail1</a> <a id="26595" class="Symbol">:</a> <a id="26597" class="Symbol">{</a><a id="26598" href="NahasTutorialModule.html#26598" class="Bound">A</a> <a id="26600" class="Symbol">:</a> <a id="26602" class="PrimitiveType">Set</a><a id="26605" class="Symbol">}</a> <a id="26607" class="Symbol">→</a> <a id="26609" class="Symbol">(</a><a id="26610" href="NahasTutorialModule.html#26610" class="Bound">as</a> <a id="26613" class="Symbol">:</a> <a id="26615" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="26620" href="NahasTutorialModule.html#26598" class="Bound">A</a><a id="26621" class="Symbol">)</a> <a id="26623" class="Symbol">→</a> <a id="26625" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="26630" href="NahasTutorialModule.html#26598" class="Bound">A</a>
<a id="26632" href="NahasTutorialModule.html#26589" class="Function">tail1</a> <a id="26638" href="NahasTutorialModule.html#24015" class="InductiveConstructor">[]</a> <a id="26641" class="Symbol">=</a> <a id="26643" href="NahasTutorialModule.html#24015" class="InductiveConstructor">[]</a>
<a id="26646" href="NahasTutorialModule.html#26589" class="Function">tail1</a> <a id="26652" class="Symbol">(</a><a id="26653" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="26658" href="NahasTutorialModule.html#26658" class="Bound">x</a> <a id="26660" href="NahasTutorialModule.html#26660" class="Bound">as</a><a id="26662" class="Symbol">)</a> <a id="26664" class="Symbol">=</a> <a id="26666" href="NahasTutorialModule.html#26660" class="Bound">as</a>

<a id="headTail"></a><a id="26670" href="NahasTutorialModule.html#26670" class="Function">headTail</a> <a id="26679" class="Symbol">:</a> <a id="26681" class="Symbol">{</a><a id="26682" href="NahasTutorialModule.html#26682" class="Bound">A</a> <a id="26684" class="Symbol">:</a> <a id="26686" class="PrimitiveType">Set</a><a id="26689" class="Symbol">}</a> <a id="26691" class="Symbol">→</a> <a id="26693" class="Symbol">(</a><a id="26694" href="NahasTutorialModule.html#26694" class="Bound">default</a> <a id="26702" class="Symbol">:</a> <a id="26704" href="NahasTutorialModule.html#26682" class="Bound">A</a><a id="26705" class="Symbol">)</a> <a id="26707" class="Symbol">→</a> <a id="26709" class="Symbol">(</a><a id="26710" href="NahasTutorialModule.html#26710" class="Bound">a</a> <a id="26712" class="Symbol">:</a> <a id="26714" href="NahasTutorialModule.html#26682" class="Bound">A</a><a id="26715" class="Symbol">)</a> <a id="26717" class="Symbol">→</a> <a id="26719" class="Symbol">(</a><a id="26720" href="NahasTutorialModule.html#26720" class="Bound">as</a> <a id="26723" class="Symbol">:</a> <a id="26725" href="NahasTutorialModule.html#23986" class="Datatype">List</a> <a id="26730" href="NahasTutorialModule.html#26682" class="Bound">A</a><a id="26731" class="Symbol">)</a> <a id="26733" class="Symbol">→</a> <a id="26735" class="Symbol">(</a><a id="26736" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="26741" class="Symbol">(</a><a id="26742" href="NahasTutorialModule.html#24704" class="Function">head1</a> <a id="26748" href="NahasTutorialModule.html#26694" class="Bound">default</a> <a id="26756" class="Symbol">(</a><a id="26757" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="26762" href="NahasTutorialModule.html#26710" class="Bound">a</a> <a id="26764" href="NahasTutorialModule.html#26720" class="Bound">as</a><a id="26766" class="Symbol">))</a> <a id="26769" class="Symbol">(</a><a id="26770" href="NahasTutorialModule.html#26589" class="Function">tail1</a> <a id="26776" class="Symbol">(</a><a id="26777" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="26782" href="NahasTutorialModule.html#26710" class="Bound">a</a> <a id="26784" href="NahasTutorialModule.html#26720" class="Bound">as</a><a id="26786" class="Symbol">)))</a> <a id="26790" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="26792" class="Symbol">(</a><a id="26793" href="NahasTutorialModule.html#24030" class="InductiveConstructor">cons</a> <a id="26798" href="NahasTutorialModule.html#26710" class="Bound">a</a> <a id="26800" href="NahasTutorialModule.html#26720" class="Bound">as</a><a id="26802" class="Symbol">)</a>
<a id="26804" href="NahasTutorialModule.html#26670" class="Function">headTail</a> <a id="26813" href="NahasTutorialModule.html#26813" class="Bound">default</a> <a id="26821" href="NahasTutorialModule.html#26821" class="Bound">a</a> <a id="26823" href="NahasTutorialModule.html#26823" class="Bound">as</a> <a id="26826" class="Symbol">=</a> <a id="26828" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

</pre>

<h2>Conclusions</h2>

<p>There are a lot of differences between the languages.  </p>

<p>I loved Agda's Emacs mode.  The tactics are just key-combos, like "C-c C-c" for case, and you see the result right away.  It's much better than having to type out "case ..." in Coq.  I feel like tactics are operations and they better suited to being built into the user interface. </p>

<p>I prefer Coq's ML-like language to Agda's Haskell-like language.  I'm much more familiar with OCaML and others like it.  But I went and read the Agda PhD thesis and I understand why they chose it.  It works well when working both forwards and backwards to assign types to expressions.  It did force me to write a lot of small helper functions, because I couldn't do "case proof<em>of</em>False" directly, like in Coq.  I know I could have defined a "case" operator, but it wouldn't have matched Agda's style.  I feel like Coq's proofs read much more like the proof style I'm used to in books.  </p>

<p>I felt that it was much harder to reason in Agda.  A lot of equality proofs were solved by just "refl", which was nice, but I never knew when that would happen.  In Coq's proofs, I used a specific subset of tactics because I knew I could control the result of them and know the state of the proof at each point.</p>

<p>A huge surprise for me was that, while the types of data and functions were essentially identical, there really wasn't a clear mapping of Coq proof to Agda proof and vice versa.  It would be hard to automatically translate from one to the other.  The proof that addition is symmetric was much easier to do in Agda than in Coq.  It did require helper functions and more operations, but I was never at risk of being lost in the proof.  I've seen an expert in Coq unable to prove symmetry of addition for 10 minutes!  Some proofs in Agda were more complicated and, often, required being split into multiple functions.  I only did simple induction proofs in Agda ... I am kinda of worried that more complicated ones would be difficult to do.  But, then again, simple ones in Coq were difficult, so maybe its less of a difference than I think.</p>

<p>It was much harder to write a "forward proof" in Agda.  The let expression exists, but it wasn't particularly easy to use.  </p>

<p>Coq's rewrite tactic is probably easier to use than Agda's sequence-of-transitive-equalities.  Agda can do the same things.  You just need to use "cong" every time you want to change a value inside an expression.  And that's got to be awkward to read and very awkward to write.  Coq's rewrite seems much simpler.</p>

<p>On a much lighter issue, I'm not sure where I stand with being able to type Unicode operators in Agda, vs. being stuck with plain text in Coq.  The biggest problem was that I could read some examples of Agda on the web, but not know how to type them in.  Eventually, I got used to it.  It saved screen real estate and it looked very mathy.  But I did have to memorize a lot of strange things like \'1 for "prime".  I will say that it was strange that Agda accepted both "->" and "→" as the same operator.  I would have just chosen one.  My problems with it could be fixed in the user interface, which might make it easier to search for and enter a symbol that you don't know.    (Although I wouldn't know where to search for '⊎'!)</p>

<p>The ",′" operator is just weird.  And I've never seen "⊎" before.  They seem like odd choice by the Agda library developers.</p>

<p>I did run into more issues with Agda.  They're listed below.  I filed bug reports for the ones I could reproduce.</p>

<h2>Agda bugs</h2>

<p>The statement:
<br><code>syntax Σ A (λ x → B) = [ x ∈ A ] × B</code><br>
on this page of the documentation:
<br> https://agda.readthedocs.io/en/v2.6.2/language/syntax-declarations.html <br>
is not accepted by Agda.</p>

<p>If you enter:
<br><code>trueCanBeProven : ⊤</code>
<br><code>trueCanBeProven = ?</code><br>
And type "C-c C-c Enter", I expected it to be solved,
since there is only 1 constructor for ⊤.  But that didn't work.
It actually DELETED the line "<code>trueCanBeProven = ?</code>"!</p>

<p>I could not get Agda to accept this function type:
<br><code>open import Data.List using (List ; []; _∷_)</code>
<br><code>consAddsOneToLength : {A : Set} → (a : A) → (as : (List A)) → ((length (a :: as)) ≡ (suc (length as)))</code><br>
It said "Not in scope:  ::"
It did not work when I used (<em>::</em> a as).
It DID work when I defined a new list with "cons" instead of "<em>::</em>".</p>

<p>When I ran this file in Emacs mode, it was able to find the libraries just fine.
When I compiled the file on the command-line, I got
<code>Failed to find source of module</code>
<code>Relation.Binary.PropositionalEquality in any of the following</code></p>

<p>UNABLE TO REPRODUCE:  Agda Emacs Mode does not handle empty agda code blocks in a literal Agda Markdown file.</p>

<p>UNABLE TO REPRODUCE
If you enter:
<br><code>equality-is-symmetric : (A : Set) → (x : A) → (y : A) → x ≡ y → y ≡ x</code>
<br><code>equality-is-symmetric A x y x-equals-y = ?</code><br>
And then type "x-equals-y" followed by "C-c C-c", I expect it to
change the pattern to match the one possible constructor of equality,
which is "refl".  But it says:
Unbound variable x-equals-y
when checking that the expression ? has type x ≡ x
BUT
It did work with this one:
<br><code>equalityIsTransitive : (A : Set) → (x : A) → (y : A) → (z : A) → x ≡ y → y ≡ z → x ≡ z</code>
<br><code>equalityIsTransitive A x y z x≡y y≡z = ?</code><br></p>

<p>Feature Request: There are many "Nat": Builtin, Base, and Data.  The manual talks about how to write an import command, but not the standard library structure and how to use it.  </p>

<p>Feature Request: Emacs mode needs a command that takes a function type declaration
and creates the first line of definition.</p>

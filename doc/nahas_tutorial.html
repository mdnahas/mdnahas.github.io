<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link href="coqdoc.css" rel="stylesheet" type="text/css" />
<title>nahas_tutorial</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library nahas_tutorial</h1>

<div class="code">
</div>

<div class="doc">
Mike Nahas's Coq Tutorial

<div class="paragraph"> </div>

Started 2012-Nov-06
Version 1.2, 2019-Jan-22
Tested with Coq version 8.10+alpha
<hr/>

Dedicated to Kernighan and Ritchie,
who wrote a magnificent introduction to a programming language.

<div class="paragraph"> </div>

<a name="lab1"></a><h1 class="section">Introduction</h1>

<div class="paragraph"> </div>

Coq is a proof assistant.  Coq helps you write formal proofs.

<div class="paragraph"> </div>

A "formal proof" is a mathematical proof that is written in a language
similar to a programming language.  (Actually, Coq's language <i>is</i> a
programming language, but we'll get to that later.)  Formal proofs are
harder for a human to read, but easier for a program to read.  The
advantage is that a formal proof can be verified by a program,
eliminating human error.

<div class="paragraph"> </div>

(NOTE: Yes, a human error could exist in the verifying program, the
operating system, the computer, etc..  The risk in the verifying
program is kept small by keeping the program very simple and small.
As for the other parts, checking a proof on multiple systems make it
much more likely that any errors are in the proofs rather than in the
verification of the proof.)

<div class="paragraph"> </div>

This tutorial will teach you the basics of using Coq to write formal
proofs.  My aim is to teach you a powerful subset of Coq's commands by
showing you lots of actual proofs.  This tutorial will not teach you
all of the Coq commands, but you will learn enough to get started
using Coq.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab2"></a><h2 class="section">Prerequisites</h2>

<div class="paragraph"> </div>

This tutorial will teach you how to use Coq to write formal proofs.  I
assume you already know how to write a proof and know about formal
logic.  I tried to make this tutorial easy to read, so if you don't
know those things, keep reading and you <i>might</i> be able to pick them
up.

<div class="paragraph"> </div>

I also assume you understand a programming language.  It doesn't
matter which programming language.

<div class="paragraph"> </div>

If you feel unprepared, the "further reading" section at the end has
useful links.

<div class="paragraph"> </div>

<a name="lab3"></a><h2 class="section">Installing Coq</h2>

<div class="paragraph"> </div>

The easiest thing is to install "CoqIDE", the graphical version of
Coq.  Windows and MacOS installers and the latest source code are
available at <a href="http://coq.inria.fr/download">http://coq.inria.fr/download</a> If you're running Linux,
your package manager probably has a recent-ish version.
(Debian/Ubuntu/Mint: "sudo apt install coqide", Fedora/CentOS might be
'su -c "yum install coq-coqide"'.  Arch might be "sudo pacman -S
coqide")

<div class="paragraph"> </div>

If you like the Emacs text editor, the alternative is to run "coqtop",
the command-line version of Coq.  It is also available at
<a href="http://coq.inria.fr/download">http://coq.inria.fr/download</a> The Linux package is usually called
"coq".  To use it in Emacs, you have to also download and install the
"Proof General" Emacs mode.  Is is available at
<a href="https://proofgeneral.github.io/">https://proofgeneral.github.io/</a> Linux package managers include some
version of it.  (Debian/Ubuntu/Mint calls it "proofgeneral".
Fedora/CentOS might call it "emacs-common-proofgeneral".  Arch might
call it "proofgeneral".)

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab4"></a><h2 class="section">Loading this file</h2>

<div class="paragraph"> </div>

This file (yes, the one you're reading right now) is a Coq file.  Coq
file's names usually end in ".v".  If this file's name currently ends
in ".txt", you'll want to change it to ".v" before loading it into
CoqIDE or Emacs.  (If this file's name ends in ".html" or ".pdf",
someone used Coq to generate this document, in which case you need to
find the original ".v" file they used.  If you can't find it, the
author hosts a recent version at
<a href="https://mdnahas.github.io/doc/nahas_tutorial.v">https://mdnahas.github.io/doc/nahas_tutorial.v</a>)

<div class="paragraph"> </div>

Once you've made sure the file's name ends in ".v", start CoqIDE or
Emacs and load the file.

<div class="paragraph"> </div>

You need to know that this file was designed to work in a specific
version of Coq.  Coq is a research tool and the developers
occasionally make small changes to its file format, so it is possible
that this file is for a different version of Coq.  As you progress
through the tutorial, you may find a proof that your version of Coq
doesn't like.  You can probably make it work, but if you can't, you
can try installing the latest version of CoqIDE and downloading the
latest version of the tutorial from the author's website.
(<a href="https://mdnahas.github.io/doc/nahas_tutorial.v">https://mdnahas.github.io/doc/nahas_tutorial.v</a>)
)

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab5"></a><h1 class="section">Comments</h1>

<div class="paragraph"> </div>

Coq will ignore everything that starts with a '(' followed by a '*'
and end with a '*' followed by a ')'.  These are called comments.

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
<a name="lab6"></a><h1 class="section">Your First Proof!</h1>

<div class="paragraph"> </div>

We'll begin by proving the proposition:
<pre>
  "for all things you could prove,
   if you have a proof of it, then you have a proof of it."
</pre>

<div class="paragraph"> </div>

Okay, that's not that exciting but we can't print "Hello, World" in Coq...

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">my_first_proof</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_A</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab7"></a><h2 class="section">Dissection of your first proof</h2>

<div class="paragraph"> </div>

A Coq proof starts by stating what you're trying to prove.  That is
done by the command "Theorem".  After the word "Theorem" comes the
name of the theorem: "my_first_proof".  If you want use this theorem
later, you'll refer to it by that name.  Then comes a colon, the
statement of what you're trying to prove, and a period ('.').

<div class="paragraph"> </div>

As you can see, every Coq command ends with a period.

<div class="paragraph"> </div>

Let's skip over how we express what you want to prove and go on to the
actual proof itself.  That starts, unsurprisingly, with the command
"Proof" (with its command-terminating period).  Then comes the actual
proof, which takes 3 steps.  Lastly, the "Qed" command ends the proof.

<div class="paragraph"> </div>

(NOTE: Instead of "Theorem", you may also see proofs that start with
"Lemma", "Remark", "Fact", "Corollary", and "Proposition", which all
mean the <i>SAME</i> thing.  In my proofs, I only use "Theorem".  Instead
of "Qed", you may also see proofs that end with "Admitted" or
"Defined", but these mean <i>DIFFERENT</i> things.  Use "Qed" for now.)

<div class="paragraph"> </div>

Coq uses 3 different "languages" and you can see them all here in this
proof.
<ul class="doclist">
<li> The "vernacular" language manages definitions and top-level
    interactions.  Each of its commands starts with a capital letter:
    "Theorem", "Proof", and "Qed".

</li>
<li> The "tactics" language is used to write proofs.  Its commands start
    with a lower-case letter: "intros" and "exact".

</li>
<li> The unnamed language of Coq terms is used to express what you want
    to prove.  Its expressions use lots of operators and
    parentheses: "(forall A : Prop, A -&gt; A)".  (Technically, this
    language is a subset of the vernacular language, but it is useful to
    think of it as its own thing.)

</li>
</ul>

<div class="paragraph"> </div>

Now, let's take a look inside this proof!  Since it probably has
scrolled off the screen, I'll reproduce it.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">my_first_proof__again</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_A</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab8"></a><h2 class="section">Seeing where you are in a proof</h2>

<div class="paragraph"> </div>

CoqIDE and Proof General are valuable because they show you the state
in the middle of your proof.  They show what you have proven and what
you still need to prove.

<div class="paragraph"> </div>

Let's see the different states inside your first proof.  Move your
cursor (by clicking your mouse or using the arrow keys) over any line
between "Proof." and "Qed.".  Now let's see the state at that point.

<div class="paragraph"> </div>

In CoqIDE, there are three ways to do it:
  1. From the menu bar, open the "Navigation" menu and select "go to"
  2. In the tool bar, click on the 5th icon (a green arrow pointing at a yellow ball)
  3. Use a keyboard combo.  On my Mac, it's control-option-rightarrow.

<div class="paragraph"> </div>

In Proof General:
  Do "C-c C-Enter" (press control-c and then control-Enter)

<div class="paragraph"> </div>

In a different part of the screen you should see something like:

<div class="paragraph"> </div>

<pre>
  A : Prop
  proof_of_A : A
  ============================
   A
</pre>

<div class="paragraph"> </div>

Everything above the bar is what you know to exist or have assumed to
exist.  These are called "hypotheses" and we refer to everything above
the bar as "the context".  Below the bar is what we are trying to
prove.  It is called "the current subgoal".

<div class="paragraph"> </div>

"The goal" is the theorem we're trying to prove.  A "subgoal" is what
we are trying to prove at any point during the proof.  We say "current
subgoal" because during a proof we may have multiple things remaining
to prove.  For example, during a proof by induction, we will have one
subgoal for the "base case" and another subgoal for the "inductive
case".  But we (usually) only work on one subgoal at a time and the
one we're working on is called "the current subgoal".

<div class="paragraph"> </div>

Now I want to explain each tactic and how it helps prove this theorem.
The proof has probably scrolled off your screen again, so here it is a
third time.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">my_first_proof__again__again</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_A</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab9"></a><h2 class="section">Your first Tactic!</h2>

<div class="paragraph"> </div>

Our starting state is:

<div class="paragraph"> </div>

<pre>

  ============================
   forall A : Prop, A -&gt; A
</pre>

<div class="paragraph"> </div>

Our goal (and current subgoal) starts with "forall A : Prop,...".  In
English, this would be "For all A such that A is a Prop, ...".  One way
to prove a statement like "For all x such that x is an integer, ..."
is to assume we have an arbitrary integer x and show that the rest of
the statement holds for x. The first tactic "intros" does exactly that.

<div class="paragraph"> </div>

Thus, every time I see "intros A.", I think "assume A".

<div class="paragraph"> </div>

The tactic "intros" takes "forall" off the front of the subgoal,
changes its variable into a hypothesis in the context, and names the
hypothesis.  Recall, the context holds all things we've proven or, as
in this case, assumed to be proven.  We named the new hypothesis "A",
which is the same as the name of the variable removed from the
subgoal.  You should always keep the same name, if possible.

<div class="paragraph"> </div>

<i>RULE</i>: If the subgoal starts with "(forall &lt;name&gt; : &lt;type&gt;, ..."
     Then use tactic "intros &lt;name&gt;.".

<div class="paragraph"> </div>

The state after "intros A." is:

<div class="paragraph"> </div>

<pre>
  A : Prop
  ============================
   A -&gt; A
</pre>

<div class="paragraph"> </div>

In Coq, "A : Prop" means you have something named "A" of type "Prop".
In the future you will see "0 : nat" which means "0" of type "nat"
(natural numbers) and you will see "true : bool" which means "true" of
type "bool" (boolean or true-false values).  In some places, you will
see "A B C : Prop", which means "A", "B", and "C" all have type
"Prop".

<div class="paragraph"> </div>

The type "Prop" is easier to explain after we've executed the next
command.  The next tactic is "intros", which we said works when
"forall" is at the front of the subgoal.  It works here because "-&gt;"
is actually shorthand for "forall".  "B -&gt; C" really means "(forall
something_of_type_B : B, C)".  So, "A-&gt;A" is "(forall
something_of_type_A : A, A)".  The result is that "intros proof_of_A."
removes that hidden "forall" and moves the unnamed variable of type A
to the hypothesis named "proof_of_A".

<div class="paragraph"> </div>

<i>RULE</i>: If the subgoal starts with "&lt;type&gt; -&gt; ..."
     Then use tactic "intros &lt;name&gt;.".

<div class="paragraph"> </div>

The state after the second "intros" command, looks like:

<div class="paragraph"> </div>

<pre>
  A : Prop
  proof_of_A : A
  ============================
   A
</pre>

<div class="paragraph"> </div>

Now, we can talk about "Prop".  "proof_of_A" is a proof.  It has type
"A", which means that "A" is something that could have a proof.  In
logic, that is called a "proposition".  Since the proposition "A" has
type "Prop", "Prop" must be the type of propositions.

<div class="paragraph"> </div>

Prop is an important concept, so let's see some propositions:
<ul class="doclist">
<li> (forall x : nat, (x &lt; 5) -&gt; (x &lt; 6))

</li>
<li> (forall x y : nat, x + y = y + x)

</li>
<li> (forall A : Prop, A -&gt; A)

</li>
</ul>

<div class="paragraph"> </div>

All of these have type "Prop".  They can all can have proofs.  That
last Prop should look familiar - it's what we're trying to prove right
now!

<div class="paragraph"> </div>

IT IS VITALLY IMPORTANT THAT YOU DO NOT THINK OF A Prop AS BEING
EITHER "TRUE" OR "FALSE".  A Prop either has a proof or it does not
have a proof.  Godel shattered mathematics by showing that some true
propositions can never proven.  Tarski went further and showed that
some propositions cannot even be said to be true or false!!!  Coq deals
with these obstacles in modern mathematics by restricting Prop to
being either proven or unproven, rather than true or false.

<div class="paragraph"> </div>

Now that I've got that across, let's go and finish our first proof.
After the second "intros" tactic, our subgoal is "A", which means "we
need something of type A" or, because A is a proposition, "we need a
proof of A".  Now, the previous command moved a proof of A into the
context and called it "proof_of_A".  So, an hypothesis in our context
(which are all things we know to exist) has a type that matches our
subgoal (which is what we want to create), so we have an exact match.
The tactic "exact proof_of_A" solves the subgoal (and the proof).

<div class="paragraph"> </div>

Ta-da!  Your first proof!

<div class="paragraph"> </div>

<i>RULE</i>: If the subgoal matches an hypothesis,
     Then use tactic "exact &lt;hyp_name&gt;.".

<div class="paragraph"> </div>

Okay, let's try something more complicated!

<div class="paragraph"> </div>

<a name="lab10"></a><h1 class="section">Proofs with -&gt;</h1>
<a name="lab11"></a><h2 class="section">Proof going forward</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">forward_small</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> -&gt; (<span class="id" title="var">A</span>-&gt;<span class="id" title="var">B</span>) -&gt; <span class="id" title="var">B</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">B</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_A</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A_implies_B</span>.<br/>
&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">proof_of_B</span> := <span class="id" title="var">A_implies_B</span> <span class="id" title="var">proof_of_A</span>).<br/>
&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_B</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Look at the tactics used in this proof.  (The tactics are the commands
between "Proof." and "Qed.")  You should be familiar with "intros" and
"exact".  The new one is "pose".  We're going to use "pose" in a
forward proof.  A "forward proof" creates larger and more complex
hypotheses in the context until one matches the goal.  Later, we'll
see a "backward proof", which breaks the goal into smaller and simpler
subgoals until they're trivial.

<div class="paragraph"> </div>

In our current proof, the state right before the "pose" command is:

<div class="paragraph"> </div>

<pre>
  A : Prop
  B : Prop
  proof_of_A : A
  A_implies_B : A -&gt; B
  ============================
   B
</pre>

<div class="paragraph"> </div>

The subgoal is "B", so we're trying to construct a proof of B.

<div class="paragraph"> </div>

In the context we have "A_implies_B : A-&gt;B".  "A-&gt;B", if you recall,
is equivalent to "(forall proof_of_A : A, B)", that is, for every
proof of A, we have a proof of B.

<div class="paragraph"> </div>

It happens that we have a proof of A in our context and it's called
(unoriginally) "proof_of_A".  The expression "A_implies_B
proof_of_A" computes the proof of B that is associated with that
particular proof of A.

<div class="paragraph"> </div>

The command "pose" assigns the result of "A_implies_B proof_of_A" to
the new hypothesis "proof_of_B".  (Note the annoying extra set of
parentheses that are necessary around the arguments to the "pose"
command.)

<div class="paragraph"> </div>

<i>RULE</i>: If you have an hypothesis
          "&lt;hyp_name&gt;: &lt;type1&gt; -&gt; &lt;type2&gt; -&gt; ... -&gt; &lt;result_type&gt;"
     OR an hypothesis
            "&lt;hyp_name&gt;: (forall &lt;obj1&gt;:&lt;type1&gt;, (forall &lt;obj2&gt;:&lt;type2&gt;, ... &lt;result_type&gt; ...))"
     OR any combination of "-&gt;" and "forall",
     AND you have hypotheses of type "type1", "type2"...,
     Then use tactic "pose" to create something of type "result_type".

<div class="paragraph"> </div>

The proof ends with the "exact" command.  We could have ended with
"exact (A_implies_B proof_of_A)", but I think it is easier to read
when it ends with with "exact proof_of_B."

<div class="paragraph"> </div>

This was a forward proof.  Let's see a backward one.

<div class="paragraph"> </div>

<a name="lab12"></a><h2 class="section">Proof going backward</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">backward_small</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> -&gt; (<span class="id" title="var">A</span>-&gt;<span class="id" title="var">B</span>)-&gt;<span class="id" title="var">B</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_A</span> <span class="id" title="var">A_implies_B</span>.<br/>
&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">A_implies_B</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_A</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Notice that we're trying to prove the exact same theorem as before.
However, I'm going to show a "backward proof" that breaks the goal
into smaller and simpler subgoals.  We will start this proof trying to
find a proof of B, but then change that to find the simpler proof of
A.

<div class="paragraph"> </div>

First, notice that the 4 "intros" commands from our last proof have
changed to just 2.  The "intros" command can take any number of
arguments, each argument stripping a forall (or -&gt;) off the front of
the current subgoal.  (WARNING: Don't use "intros" with no arguments
at all - it doesn't do what you'd expect!)  We could have combined all
the "intros" into a single command, but I think it is cleaner to
introduce the Props and the derived values separately.

<div class="paragraph"> </div>

The state right before the "refine" command is:

<div class="paragraph"> </div>

<pre>
  A : Prop
  B : Prop
  proof_of_A : A
  A_implies_B : A -&gt; B
  ============================
   B
</pre>

<div class="paragraph"> </div>

The subgoal is the Prop "B", so we're trying to construct a proof of
B.

<div class="paragraph"> </div>

We know that "A_implies_B" can create a proof of B, given a proof of
A.  We saw the syntax for it was "A_implies_B something_of_type_A".
The command "refine (A_implies_B _)." let's us create the proof of B
without specifying the argument of type A.  (The parentheses are
necessary for it to parse correctly.)  This solves our current subgoal
of type B and the unspecified argument - represented by the underscore
("_") - become a new "child" subgoal.

<div class="paragraph"> </div>

<pre>
  A : Prop
  B : Prop
  proof_of_A : A
  A_implies_B : A -&gt; B
  ============================
   A
</pre>

<div class="paragraph"> </div>

In this case, the child subgoal has us trying to find a proof of A.
Since it's a child subgoal, we indent the tactics used to solve it.
And the tactic to solve it is our well worn "exact".

<div class="paragraph"> </div>

<i>RULE</i>: If you have subgoal "&lt;goal_type&gt;"
     AND have hypothesis
          "&lt;hyp_name&gt;: &lt;type1&gt; -&gt; &lt;type2&gt; -&gt; ... -&gt; &lt;typeN&gt; -&gt; &lt;goal_type&gt;",
     Then use tactic "refine (&lt;hyp_name&gt; _  ...)." with N underscores.

<div class="paragraph"> </div>

The important thing to take away from this proof is that we changed
the subgoal.  That's what happens in a backward proof.  You keep
changing the subgoal to make it smaller and simpler.  "A" doesn't seem
much smaller or simpler than "B", but it was.

<div class="paragraph"> </div>

Now, let's rev this up...

<div class="paragraph"> </div>

<a name="lab13"></a><h2 class="section">Proof going backward (large)</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">backward_large</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> -&gt; (<span class="id" title="var">A</span>-&gt;<span class="id" title="var">B</span>) -&gt; (<span class="id" title="var">B</span>-&gt;<span class="id" title="var">C</span>) -&gt; <span class="id" title="var">C</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_A</span> <span class="id" title="var">A_implies_B</span> <span class="id" title="var">B_implies_C</span>.<br/>
&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">B_implies_C</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">A_implies_B</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_A</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Look at the sequence of tactics.  It starts with a pair of "intros"s.
That's followed by the new kid on the block "refine".  We finish with
"exact".  That pattern will start to look familiar very soon.

<div class="paragraph"> </div>

The state before the first "refine" is:

<div class="paragraph"> </div>

<pre>
  A : Prop
  B : Prop
  C : Prop
  proof_of_A : A
  A_implies_B : A -&gt; B
  B_implies_C : B -&gt; C
  ============================
   C
</pre>

<div class="paragraph"> </div>

Our current subgoal is "C" and "C" is at the end of "B -&gt; C", so we
can do "refine (B_implies_C _)".  That command creates a new child
subgoal "B".

<div class="paragraph"> </div>

Then, our subgoal is "B" and "B" is at the end of "A -&gt; B", so "refine
(A_implies_B _)" creates a new child subgoal of "A".

<div class="paragraph"> </div>

Then we finish with "exact proof_of_A.".  Easy as pie.

<div class="paragraph"> </div>

Let's do a really big example!

<div class="paragraph"> </div>

<a name="lab14"></a><h2 class="section">Proof going backward (huge)</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">backward_huge</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> -&gt; (<span class="id" title="var">A</span>-&gt;<span class="id" title="var">B</span>) -&gt; (<span class="id" title="var">A</span>-&gt;<span class="id" title="var">B</span>-&gt;<span class="id" title="var">C</span>) -&gt; <span class="id" title="var">C</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_A</span> <span class="id" title="var">A_implies_B</span> <span class="id" title="var">A_imp_B_imp_C</span>.<br/>
&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">A_imp_B_imp_C</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_A</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">A_implies_B</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_A</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Yes, something is different here!  We have our starting "intros"s.  We
have a "refine".  But then the commands are indented and we have two
"exact"s!

<div class="paragraph"> </div>

The state before the first refine is:

<div class="paragraph"> </div>

<pre>
  A : Prop
  B : Prop
  C : Prop
  proof_of_A : A
  A_implies_B : A -&gt; B
  A_imp_B_imp_C : A -&gt; B -&gt; C
  ============================
   C
</pre>

<div class="paragraph"> </div>

Now, we have a subgoal "C" and "C" is at the end of "A-&gt;B-&gt;C", so we
can do "refine (A_imp_B_imp_C _ )".  Notice that "A_imp_B_imp_C" has
two implication arrows (the "-&gt;"s), so refine requires two underscores
and creates two subgoals - one for something of type A and another for
something of type B.

<div class="paragraph"> </div>

I hinted that a formal proof is actually written in a programming
language.  We see that very clearly here.  "A_imp_B_imp_C" is a
function that takes two arguments, one of type A and one of type B,
and returns a value of type C.  The type of the function is "A-&gt;B-&gt;C"
and a call to it looks like "A_imp_B_imp_C something_of_type_A
something_of_type_B".  Notice that there are no parentheses needed -
you just put the arguments next to the name of the function.  For
example, "function arg1 arg2". This is a style common in functional
programming languages.  For those familiar with imperative languages,
like C, C++, and Java, it will feel odd not to have parentheses and
commas to denote the arguments.

<div class="paragraph"> </div>

The first "refine" created two subgoals.  CoqIDE and Proof General
will tell you that two subgoals exist, but they will only show you the
context for the current subgoal.

<div class="paragraph"> </div>

In the text of the proof, we represent that "refine" created multiple
subgoals by formatting them like an "if-then-else" or "switch/match"
statement in a programming language.  The proofs for each subgoal get
indented and we use a blank line to separate them.

<div class="paragraph"> </div>

The proof of the first subgoal is trivial.  We need an "A" and we have
"proof_of_A : A".  "exact proof_of_A" completes the subgoal.  We now
put the blank line in the proof to show we're moving on to the next
subgoal.

<div class="paragraph"> </div>

The rest of the proof we've seen before.  The proof for it is indented
to show it's the result of a "branch" in the proof created by "refine
(A_imp_B_impC _ )".

<div class="paragraph"> </div>

Having seen this complex theorem proved with a backward proof, let's
see what it would look like with a forward one.

<div class="paragraph"> </div>

<a name="lab15"></a><h2 class="section">Proof going forward (huge)</h2>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">forward_huge</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> -&gt; (<span class="id" title="var">A</span>-&gt;<span class="id" title="var">B</span>) -&gt; (<span class="id" title="var">A</span>-&gt;<span class="id" title="var">B</span>-&gt;<span class="id" title="var">C</span>) -&gt; <span class="id" title="var">C</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>.<br/>
&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_A</span> <span class="id" title="var">A_implies_B</span> <span class="id" title="var">A_imp_B_imp_C</span>.<br/>
&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">proof_of_B</span> := <span class="id" title="var">A_implies_B</span> <span class="id" title="var">proof_of_A</span>).<br/>
&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">proof_of_C</span> := <span class="id" title="var">A_imp_B_imp_C</span> <span class="id" title="var">proof_of_A</span> <span class="id" title="var">proof_of_B</span>).<br/>
&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_C</span>.<br/>
<span class="id" title="keyword">Show</span> <span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This is the same theorem as before, except it has a forward proof
instead of a backward one.

<div class="paragraph"> </div>

In this proof, we can see the programming language underneath the
proof.  "A_implies_B" is a function with type "A-&gt;B", so when it is
call with argument "proof_of_A", it generates a proof of B.  The
"pose" command assigns the resulting value to the (unimaginative) name
"proof_of_B".

<div class="paragraph"> </div>

Likewise, "A_imp_B_imp_C" is a function with type "A-&gt;B-&gt;C".  Called
with "proof_of_A" and "proof_of_B", it produces a proof of C which
becomes the hypothesis "proof_of_C".

<div class="paragraph"> </div>

There is a new vernacular command at the end: "Show Proof".  If you
put your cursor right after it and press "control-option-right_arrow"
(in CoqIDE) or "C-C C-Enter" (in Proof General), you'll see the actual
code for the proof.  It looks like this:

<div class="paragraph"> </div>

<pre>
  (fun (A B C : Prop)
       (proof_of_A : A) (A_implies_B : A -&gt; B) (A_imp_B_imp_C : A -&gt; B -&gt; C)
   =&gt;
     let proof_of_B := A_implies_B proof_of_A in
     let proof_of_C := A_imp_B_imp_C proof_of_A proof_of_B in
       proof_of_C)
</pre>

<div class="paragraph"> </div>

I formatted this version so that the correspondence to the proof is
clearer.  The "intros" commands declare the parameters for the
function.  "pose" declares constant values in the function.  Lastly,
the "exact" command is used to return the result of the function.  As
we go, you'll see the tight relationship in Coq between proofs and
code.

<div class="paragraph"> </div>

At this point, I want to emphasize that Coq proofs are not normally
this tedious or verbose.  The proofs I've shown and the proofs I will
show are demonstrating the mechanics of how Coq works.  I'm using
simple familiar types to make the mechanics' operations clear to you.
Coq's tactic language contains commands for automatic theorem proving
and for defining macros.  Almost all the proofs in this tutorial are
simple enough to dispatch with a single Coq tactic.  But when you
prove more complicated statements, you'll need all the commands I'm
teaching in this tutorial.

<div class="paragraph"> </div>

This helps explain why most Coq proofs are backwards.  Once a
goal has been transformed into simple enough subgoals, those
subgoals can each be proved by automation.

<div class="paragraph"> </div>

So far, we've only worked with proofs, propositions, and Prop.  Let's
add some more types!

<div class="paragraph"> </div>

<a name="lab16"></a><h1 class="section">true and false vs. True and False</h1>

<div class="paragraph"> </div>

The vernacular command "Inductive" lets you create a new type.  I
wanted to introduce the boolean type, which has two values: "true" and
"false".  The problem is that in addition to "true" and "false", Coq
has two other entities named "True" and "False", where the first
letter is capitalized.  To keep the differences straight in your mind,
I'm going to introduce them to you all at once.

<div class="paragraph"> </div>

<pre>
Inductive False : Prop := .

Inductive True : Prop :=
  | I : True.

Inductive bool : Set :=
  | true : bool
  | false : bool.
</pre>

<div class="paragraph"> </div>

<ul class="doclist">
<li> Capital-F "False" is a Prop with no proofs.

</li>
<li> Capital-T "True" is a Prop that has a single proof called "I".
   (That's a capital-I, not a number 1.)

</li>
<li> Lastly, "bool" is a Set and "bool" has two elements:
  lower-case-t "true" and lower-case-f "false".

</li>
</ul>

<div class="paragraph"> </div>

I find these names confusing.  Recall that "Prop"s are things that may
have a proof.  So I think capital-T "True" and capital-F "False" should
have been named "Provable" and "Unprovable" (or "AlwaysProvable"
and "NeverProvable").  The lower-case ones act like what you're
accustomed to.

<div class="paragraph"> </div>

Since we've been playing with Props, let's do some proofs with (the
badly named) "True" and "False" and we'll come back to the lower-case
"true" and "false" later.  
<div class="paragraph"> </div>

<a name="lab17"></a><h2 class="section">Capital-T True and Capital-F False</h2>
<a name="lab18"></a><h3 class="section">True is provable</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">True_can_be_proven</span> : <span class="id" title="var">True</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
If we look at the state before the first (and only) line of the proof,
we see:

<div class="paragraph"> </div>

<pre>

  ============================
   True
</pre>

<div class="paragraph"> </div>

There are no hypotheses; the context is empty.  We are trying to find
a proof of True.  By its definition, True has a single proof called
"I".  So, "exact I." solves this proof.

<div class="paragraph"> </div>

<i>RULE</i>: If your subgoal is "True",
     Then use tactic "exact I.".

<div class="paragraph"> </div>

Now, we turn to False.

<div class="paragraph"> </div>

<a name="lab19"></a><h3 class="section">Unprovability</h3>

<div class="paragraph"> </div>

I wrote earlier that a proposition either has a proof or it does not
(yet) have a proof.  In some cases, we can prove that a proposition
can never have a proof.  We do that by showing that for every possible
proof of a proposition, we could generate a proof of False.  Because
False has no proofs (by its definition), we know that the proposition
has no proofs.

<div class="paragraph"> </div>

So, to show that "A : Prop" has no proofs, we need to show
<ul class="doclist">
<li> (forall proof_of_A: A, False)

</li>
</ul>
Or, equivalently
<ul class="doclist">
<li> A -&gt; False

</li>
</ul>

<div class="paragraph"> </div>

We do this so often that there is an operator "~" to represent it.

<div class="paragraph"> </div>

<pre>
Definition not (A:Prop) := A -&gt; False.

Notation "~ x" := (not x) : type_scope.
</pre>

<div class="paragraph"> </div>

"Definition" is a vernacular command that says two things are
interchangeable.  So, "(not A)" and "A -&gt; False" are interchangeable.

<div class="paragraph"> </div>

"Notation" is a vernacular command that creates an operator, in this
case "~", and defines it as an alternate notation for an expression,
in this case "(not _)".  Since "not" takes a Prop, "~" can only be
applied to a Prop.

<div class="paragraph"> </div>

(NOTE: The Notation command is how the operator "-&gt;" was created
for "(forall ...)".)

<div class="paragraph"> </div>

Let's try to prove some things are unprovable!

<div class="paragraph"> </div>

<a name="lab20"></a><h3 class="section">False is unprovable</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">False_cannot_be_proven</span> : ~<span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_False</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_False</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The only new tactic here is "unfold".  We said "Definition" says two
expressions are interchangeable.  Well, "unfold" and "fold" will
interchange them.  After the "unfold", we have

<div class="paragraph"> </div>

<pre>

  ============================
   False -&gt; False
</pre>

<div class="paragraph"> </div>

The "unfold" exposes that "~" is really an "-&gt;".  And we're very
familiar with using the tactic "intros" to remove "-&gt;" at the front of
the subgoal.  The command "intros proof_of_False" does just that.

<div class="paragraph"> </div>

After that, it goes as usual.  "intros"s at the start and "exact" at
the end.  It feels weird to have an hypothesis labeled
"proof_of_False" doesn't it?  It's weird because we know False has no
proofs, so that hypothesis can never exist.  Wouldn't it be better if
we could say that directly?...

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">False_cannot_be_proven__again</span> : ~<span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_False</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">proof_of_False</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This is the same theorem as before, but two things have changed in
this proof.

<div class="paragraph"> </div>

First, it doesn't have "unfold not.".  Since we know "~" is shorthand
for "-&gt;", we can skip over the unfold tactic and go straight to using
"intros".

<div class="paragraph"> </div>

<i>RULE</i>: If your subgoal is "~&lt;type&gt;" or "~(&lt;term&gt;)" or "(not &lt;term&gt;)",
     Then use tactic "intros".

<div class="paragraph"> </div>

The second change is that we found a new way to finish a proof!
Instead of "exact", we use the "case" tactic.  "case" is
powerful: it creates subgoals for every possible construction of its
argument.  Since there is no way to construct a False, "case"
creates no subgoals!  Without a subgoal, we're done!

<div class="paragraph"> </div>

<i>RULE</i>: If any hypothesis is "&lt;name&gt; : False",
     Then use tactic "case &lt;name&gt;.".

<div class="paragraph"> </div>

<a name="lab21"></a><h3 class="section">-&gt; Examples</h3>

<div class="paragraph"> </div>

We can use True and False to see that Coq's "-&gt;" operator really does
act like "implication" from logic.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">thm_true_imp_true</span> : <span class="id" title="var">True</span> -&gt; <span class="id" title="var">True</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_True</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>. </div>

<div class="doc">
"exact proof_of_True." also works. 
</div>
<div class="code">
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">thm_false_imp_true</span> : <span class="id" title="var">False</span> -&gt; <span class="id" title="var">True</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_False</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>. </div>

<div class="doc">
"case proof_of_False." also works. 
</div>
<div class="code">
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">thm_false_imp_false</span> : <span class="id" title="var">False</span> -&gt; <span class="id" title="var">False</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_False</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">proof_of_False</span>. </div>

<div class="doc">
"exact proof_of_False." works, but is not recommended. 
</div>
<div class="code">
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
True-&gt;False can never be proven.  We demonstrate that by
proving ~(True-&gt;False). 
</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">thm_true_imp_false</span> : ~(<span class="id" title="var">True</span> -&gt; <span class="id" title="var">False</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">T_implies_F</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">T_implies_F</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
All of the above proofs should be obvious to you by now.

<div class="paragraph"> </div>

<a name="lab22"></a><h3 class="section">Reducto ad absurdium</h3>

<div class="paragraph"> </div>

Below is another staple of logic: reduction to absurdity.  If a
proposition has a proof and you prove that it cannot have a proof, then
you can conclude anything.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">absurd2</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">C</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> -&gt; ~ <span class="id" title="var">A</span> -&gt; <span class="id" title="var">C</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">C</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_A</span> <span class="id" title="var">proof_that_A_cannot_be_proven</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> <span class="id" title="var">proof_that_A_cannot_be_proven</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">proof_of_False</span> := <span class="id" title="var">proof_that_A_cannot_be_proven</span> <span class="id" title="var">proof_of_A</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">proof_of_False</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

This is a tricky proof.  Since our subgoal "C" doesn't appear in our
hypotheses, we cannot end the proof with "exact something_of_type_C".
The only other option we know (so far) is "case" on a proof of False.

<div class="paragraph"> </div>

The tactic "unfold ... in" is used to interchange the definition of
"not" in a hypothesis.  That exposes that the type "~A" is really
"A -&gt; False", that is, a function from a proof of A to a proof of False.

<div class="paragraph"> </div>

With that knowledge, we can call the function with "proof_of_A" to get
a proof of False.  And we end the proof with "case" on a proof of
False!

<div class="paragraph"> </div>

That was a serious proof!  But we've done about as much as we can do
with Props, so let's get back to bools!

<div class="paragraph"> </div>

<a name="lab23"></a><h2 class="section">The return of lower-case true and lower-case false</h2>

<div class="paragraph"> </div>

Now, remember when I introduced capital-T True and capital-F False of
type Prop, I also introduced the type "bool".  Type "bool" has two
different constructors: lower-case-t true and lower-case-f false.

<div class="paragraph"> </div>

<pre>
Inductive bool : Set :=
  | true : bool
  | false : bool.
</pre>

<div class="paragraph"> </div>

"true" and "false" have type "bool" and "bool" has type "Set".  "Set"
is the type of normal datatypes, like "bool" and natural numbers and
most of the other types you'll see.  The exception is propositions,
which have type "Prop".

<div class="paragraph"> </div>

Let's load some helper functions for the type "bool".

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">Bool</span>.<br/>

<br/>
</div>

<div class="doc">
"Require Import" is a vernacular command that loads definitions from a
library.  In this case, the library is named "Bool" and there is a
file named "Bool.v" that contains its definitions, proofs, etc..

<div class="paragraph"> </div>

Two of the functions are:
<pre>
Definition eqb (b1 b2:bool) : bool :=
  match b1, b2 with
    | true, true =&gt; true
    | true, false =&gt; false
    | false, true =&gt; false
    | false, false =&gt; true
  end.

Definition Is_true (b:bool) :=
  match b with
    | true =&gt; True
    | false =&gt; False
  end.
</pre>

<div class="paragraph"> </div>

The first function "eqb" returns true if the two arguments match.
("eqb" is short for "equal for type bool".)

<div class="paragraph"> </div>

The second function "Is_true" converts a bool into a Prop.  In the
future, you can use "(&lt;name&gt; = true)", but we haven't described "="
yet.  The operator "=" is REALLY cool, but you have to understand more
basic types, like bool, first.

<div class="paragraph"> </div>

Let's do some proofs with these functions.

<div class="paragraph"> </div>

<a name="lab24"></a><h3 class="section">Is_true true is True</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">true_is_True</span>: <span class="id" title="var">Is_true</span> <span class="id" title="var">true</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

"Is_true" is a function, so "Is_true true" is that function called
with the argument "true".  Since "Is_true"'s type is "bool-&gt;Prop", we
know that the function call returns a "Prop", which is something that
can be proven.  So, this proof demonstrates that there exists a proof
for "Is_true true".

<div class="paragraph"> </div>

Admittedly, "Is_true true" seems like a dumb thing to prove.  Later,
we'll replace the argument "true" with more useful boolean
expressions, like "4 &lt; 5" and other comparisons.

<div class="paragraph"> </div>

The proof contains a new tactic: "simpl".  It is short for "simplify".
If you have a function call and you have the definition of the
function, the tactic "simpl" will execute the function on the
arguments.  In this case, the function returns something of type Prop
and that Prop happens to be "True".  (Yes, the function returned a
type.  This is common in Coq.)

<div class="paragraph"> </div>

"True" becomes our new subgoal.  And we've seen how to prove a subgoal
of "True" and that's "exact I" because "True" was defined to have a
single proof named "I".

<div class="paragraph"> </div>

<i>RULE</i>: If the current subgoal contains a function call with all its arguments,
     Then use the tactic "simpl.".

<div class="paragraph"> </div>

I promised that you would see "Is_true" with a more complex argument.
So, let me show you that.

<div class="paragraph"> </div>

<a name="lab25"></a><h3 class="section">Is_true called with a complex constant.</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">not_eqb_true_false</span>: ~(<span class="id" title="var">Is_true</span> (<span class="id" title="var">eqb</span> <span class="id" title="var">true</span> <span class="id" title="var">false</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">False_cannot_be_proven</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The tactic "simpl" executes the functions to produce a subgoal of
"~False".  That should look familiar, because we've proved it before!
We could copy-and-paste the proof <i>OR</i> we could just say the proof
already exists!  We gave the proof of "~False" the name
"False_cannot_be_proven", so the tactic "exact False_cannot_be_proven"
finishes the proof immediately!  Sweet, isn't it?

<div class="paragraph"> </div>

Now, let's look at a more complex call to Is_true, where we'll get to
see the tactic "case" show its power!

<div class="paragraph"> </div>

<a name="lab26"></a><h3 class="section">case with bools</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">eqb_a_a</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> : <span class="id" title="var">bool</span>, <span class="id" title="var">Is_true</span> (<span class="id" title="var">eqb</span> <span class="id" title="var">a</span> <span class="id" title="var">a</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">a</span>.<br/>
</div>

<div class="doc">
suppose a is true 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>

<br/>
</div>

<div class="doc">
suppose a is false 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Take a look at the state after "case a.".  There's two subgoals!  I
said before that "case" creates subgoals for every possible
construction of its argument.  So far, we've only used "case" with
hypotheses of type "False".  False has no constructors, so it
generates no subgoals and ends our proofs.

<div class="paragraph"> </div>

Hypotheses of type "bool" have two possible constructors "true" and
"false".  Thus, "case a" creates two new subgoals - one where "a" has
been replaced by "true" and a second where "a" has been replaced by
"false".

<div class="paragraph"> </div>

NOTE: The replacement of "a" by "true" (or "false") only happens
inside the subgoal.  It does NOT happen in the hypotheses.  It is
sometimes important to control where "a" is before calling "case"!

<div class="paragraph"> </div>

I believe it is good style to label the two different cases.  I do
that with the comment "suppose &lt;hyp&gt; is &lt;constructor&gt;".  Since the
definition of "bool" listed "true" before "false", the subgoal where
"a" is "true" becomes the current subgoal.  Once we prove it, the case
where "a" is "false" will become the current subgoal.

<div class="paragraph"> </div>

<i>RULE</i>: If there is a hypothesis "&lt;name&gt;" of a created type
     AND that hypothesis is used in the subgoal,
     Then you can try the tactic "case &lt;name&gt;.".

<div class="paragraph"> </div>

Let's do one more example.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">thm_eqb_a_t</span>: (<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>:<span class="id" title="var">bool</span>, (<span class="id" title="var">Is_true</span> (<span class="id" title="var">eqb</span> <span class="id" title="var">a</span> <span class="id" title="var">true</span>)) -&gt; (<span class="id" title="var">Is_true</span> <span class="id" title="var">a</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">a</span>.<br/>
</div>

<div class="doc">
suppose a is true 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_True</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>

<br/>
</div>

<div class="doc">
suppose a is false 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_False</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">proof_of_False</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
In this example, I had to control the location of "a" when using the
tactic "case".

<div class="paragraph"> </div>

Usually, we would do "intros a" followed by another "intros" to move
everything before the "-&gt;" into a hypothesis.  If we did this, one
usage of "a" would move from the subgoal into a hypothesis and "case
a" would NOT replace it with "true" or "false".  (The "case" tactic
only changes the subgoal.)  And we'd be unable to prove the theorem.

<div class="paragraph"> </div>

Instead, I left "a" in the subgoal and delayed the second "intros"
until after the "case" command.  (In fact, after the "simpl" too.)  As
a result, all usages of "a" were replaced by "true" or "false" and the
theorem was provable.

<div class="paragraph"> </div>

<a name="lab27"></a><h1 class="section">And, Or</h1>

<div class="paragraph"> </div>

One of the most amazing things about Coq is its fundamental rules are
so simple that even things like "and" and "or" can be defined in terms
of them.  I'll start with "or" because it shows some special features.
<a name="lab28"></a><h2 class="section">Or</h2>

<div class="paragraph"> </div>

Before showing you the definition for "or", I want you to see some
examples so that the definition will make sense.  In the examples
below, imagine you have a hypothesis with a natural number "x".
<ul class="doclist">
<li> (or (x &lt; 5) (x = 7))

</li>
<li> (or True False)

</li>
<li> (or (x = 0) (x = 1))

</li>
</ul>
As you can see, "or" is a function.  Each of its arguments are
propositions - each of them are things that could be proved.  And we
know that the "or" itself can be proved, so the result of call to "or"
must be a proposition.  Since a proposition has type "Prop", the type
of "or" is:
<ul class="doclist">
<li> or (A B:Prop) : Prop

</li>
</ul>
That is, a function that it takes two propositions, A and B, and
returns a proposition.

<div class="paragraph"> </div>

I said the result of "or" is a proposition - something that might have
a proof.  So how do we create a proof of "or"?  For that, we need to
see the definition...

<div class="paragraph"> </div>

<pre>
Inductive or (A B:Prop) : Prop :=
  | or_introl : A -&gt; A \/ B
  | or_intror : B -&gt; A \/ B
where "A \/ B" := (or A B) : type_scope.
</pre>

<div class="paragraph"> </div>

This vernacular command does four things.
<ul class="doclist">
<li> declares "or",
     a function that takes two Props and produces a Prop

</li>
<li> declares "or_introl",
     a constructor that takes a proof of "A" and returns a proof of "(or A B)"

</li>
<li> declares "or_intror",
     a constructor that takes a proof of "B" and returns a proof of "(or A B)"

</li>
<li> declares "\/",
     an operator that is interchangeable with "or"

</li>
</ul>

<div class="paragraph"> </div>

One way to think of this is to say "(or A B)" creates a type and
"(or_introl proof_of_A)" and "(or_intror proof_of_B)" are instances of
that type.  In fact, the ONLY way to create things of type "or" is by
using the constructors "or_introl" and "or_intror".

<div class="paragraph"> </div>

It is important to note that constructors, like "or_introl" and
"or_intror", are functions that can be called, but do not have any
definitions.  They are not made of calls to other functions.  They
cannot be executed and the result looked at.  The tactic "simpl" will
not remove them.  They are opaque constants.

<div class="paragraph"> </div>

The vernacular command "Inductive" creates new types.  It's called
"Inductive" since it lets you create inductive types, although none of
our types so far has been inductive.  (That will change!)  It is the
same command we saw earlier to declare other new types with their
constants.

<div class="paragraph"> </div>

<pre>
Inductive False : Prop := .

Inductive True : Prop :=
  I : True.

Inductive bool : Set :=
  | true : bool
  | false : bool.
</pre>

<div class="paragraph"> </div>

Right now, we want to play with "or", so let's get proving!

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">left_or</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">A</span> \/ <span class="id" title="var">B</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">proof_of_A_or_B</span> := <span class="id" title="var">or_introl</span> <span class="id" title="var">proof_of_A</span> : <span class="id" title="var">A</span> \/ <span class="id" title="var">B</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_A_or_B</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This proof should have gone pretty much as you expected.  The only
complication is that the "pose" command could not infer the type of B
from "or_introl proof_of_A", so the type had to be given explicitly by
putting ": A \/ B" at the end.  "or_introl proof_of_A" by itself is a
proof of "A \/ anything".

<div class="paragraph"> </div>

The proof is shorter without the "pose", since Coq knows the type from
the subgoal we're trying to prove.  You can see this in a similar proof
using "or_intror" below.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">right_or</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">B</span> -&gt; <span class="id" title="var">A</span> \/ <span class="id" title="var">B</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">or_intror</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_B</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
An even shorter proof would have just "exact (or_intror proof_of_B)".
But if you don't know all the constructor's arguments, using "refine"
is a fine approach.

<div class="paragraph"> </div>

<i>RULE</i>: If the subgoal's top-most term is a created type,
     Then use "refine (&lt;name_of_constructor&gt; _  ...).".

<div class="paragraph"> </div>

Let's prove something a little more complicated...

<div class="paragraph"> </div>

<a name="lab29"></a><h3 class="section">Or commutes</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">or_commutes</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>, <span class="id" title="var">A</span> \/ <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span> \/ <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A_or_B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">A_or_B</span>.<br/>
</div>

<div class="doc">
suppose A_or_B is (or_introl proof_of_A) 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">or_intror</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_A</span>.<br/>

<br/>
</div>

<div class="doc">
suppose A_or_B is (or_intror proof_of_B) 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">or_introl</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_B</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
This proof uses the tactic "case" to consider the two different ways
we might have constructed the hypothesis "A \/ B".  One possibility
was using "(or_introl proof_of_A)", which would have meant there was a
proof of "A".  For that case, the tactic puts "A -&gt;" at the front of the
subgoal and we use "intros proof_of_A." to move the proof into the context.
Notice that "case" changed the subgoal and not the context.  "case"
never changes the context - that's a useful property to know (and look
out for) when working with it.

<div class="paragraph"> </div>

The other possibility for creating the hypothesis "A \/ B" was that
the constructor "or_intror" was used.  For it to be used, there had to
exist a proof of "B".  So, for the second case created by "case", the
subgoal has "B -&gt;" at the front and we use "intros proof_of_B." to move
it into the context.

<div class="paragraph"> </div>

Once the "proof_of_A" or "proof_of_B" is in the context, the proofs of
each subgoal follow the pattern we've seen before.

<div class="paragraph"> </div>

Now that we've seen how "or" works, let's take a look at "and".

<div class="paragraph"> </div>

<a name="lab30"></a><h2 class="section">And</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

I think we can go straight to the definition.

<div class="paragraph"> </div>

<pre>
Inductive and (A B:Prop) : Prop :=
  conj : A -&gt; B -&gt; A /\ B

where "A /\ B" := (and A B) : type_scope.
</pre>

<div class="paragraph"> </div>

As you could expect, "and" is a function that takes two Props and
returns a Prop.  That's the exact same as we saw with "or".  However,
while "or" had two constructors that each took one argument, "and" has
a single constructor that takes two arguments.  So, the one and only
way to create something of type "(and A B)" is to use "(conj
proof_of_A proof_of_B)".

<div class="paragraph"> </div>

Let's go straight to a proof!

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">both_and</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span> : <span class="id" title="keyword">Prop</span>, <span class="id" title="var">A</span> -&gt; <span class="id" title="var">B</span> -&gt; <span class="id" title="var">A</span> /\ <span class="id" title="var">B</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_A</span> <span class="id" title="var">proof_of_B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">conj</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_A</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_B</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Pretty simple proof.  There is only one constructor for things of type
"(and A B)", which is "conj".  It takes two arguments, which after
"refine", become two subgoals.  The proofs of each are trivial.

<div class="paragraph"> </div>

After seeing "or", "and" should be easy, so let's jump to the complex
proof.
<a name="lab31"></a><h3 class="section">And commutes</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">and_commutes</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>, <span class="id" title="var">A</span> /\ <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span> /\ <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A_and_B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">A_and_B</span>.<br/>
</div>

<div class="doc">
suppose A_and_B is (conj proof_of_A proof_of_B) 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">proof_of_A</span> <span class="id" title="var">proof_of_B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">conj</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_B</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_A</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The "case" tactic looked at all the different ways to construct an
"and" in the hypothesis and found there was only one: "(conj
proof_of_A proof_of_B)".  So, the tactic created one subgoal with both
of those required values at the front of the subgoal.

<div class="paragraph"> </div>

Similarly, when we need to build an "and" to satisfy the subgoal,
there is only one way to construct an "and": "conj" with two
arguments.  Thus, after "refine" two subgoals were created, one
requiring something of type "B" and the other requiring something of
type "A".

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab32"></a><h3 class="section">destruct tactic</h3>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

The previous proof used "case" to create subgoals for all constructors
for something of type "A /\ B".  But there was only one constructor.
So, we really didn't need to indent.  Nor should we waste a line with
a comment saying "suppose".  And it'd be really nice if we didn't have
to write the "intros" command.

<div class="paragraph"> </div>

Luckily, Coq provides a tactic called "destruct" that is a little more
versatile than "case".  I recommend using it for types that have a
single constructor.  The format is:

<div class="paragraph"> </div>

<pre>
  destruct &lt;hyp&gt; as [ &lt;arg1&gt; &lt;arg2&gt; ... ].
</pre>

<div class="paragraph"> </div>

I put a comment with the name of the constructor inside the square
braces.

<div class="paragraph"> </div>

The result is a much shorter and cleaner proof.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">and_commutes__again</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>, <span class="id" title="var">A</span> /\ <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span> /\ <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A_and_B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">A_and_B</span> <span class="id" title="keyword">as</span> [ <span class="id" title="var">proof_of_A</span> <span class="id" title="var">proof_of_B</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">conj</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_B</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_A</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<i>RULE</i>: If a hypothesis "&lt;name&gt;" is a created type with only one constructor,
      Then use "destruct &lt;name&gt; as <span class="inlinecode"></span> <span class="inlinecode">&lt;<span class="id" title="var">arg1</span>&gt;</span> <span class="inlinecode">&lt;<span class="id" title="var">arg2</span>&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode"></span>" to extract its arguments.

<div class="paragraph"> </div>

<a name="lab33"></a><h3 class="section">functions and inductive types</h3>

<div class="paragraph"> </div>

We just saw that "and" and "or" work with Props and are inductive
types.  In this section, I'll introduce "andb" and "orb" for working
with "bool"s.  Rather than inductive types, "andb" and "orb" are
functions.

<div class="paragraph"> </div>

To be clear, "and" and "or" are "inductive types" - that is, types we
defined where instances can only be produced by calling opaque
functions called constructors.  Those constructors are things like
"or_introl", "or_intror", and "conj".

<div class="paragraph"> </div>

In fact, the type "bool" is also inductive type.  It has two
constructors: "true" and "false".  These constructors take no
arguments, so they are closer to constants than "opaque functions".

<div class="paragraph"> </div>

To manipulate "bool"s, we could use an inductive type, but it's much
easier just to define a function.  We've already seen one function on
bools: "eqb", which did equality.  Some other functions that Coq defines are:

<div class="paragraph"> </div>

<ul class="doclist">
<li> andb (b1 b2:bool) : bool

</li>
<li> orb (b1 b2:bool) : bool

</li>
<li> negb (b:bool) : bool

</li>
</ul>

<div class="paragraph"> </div>

These are "and", "or", and "not" (but called "negation" for some reason).
Like with "eqb", the names all ended in "b" to indicate they work with
"bool"s.  Two of these functions also come with operators:

<div class="paragraph"> </div>

<pre>
Infix "&amp;&amp;" := andb : bool_scope.
Infix "||" := orb : bool_scope.
</pre>

<div class="paragraph"> </div>

We'll get some good practice proving that these functions on bools are
equivalent to our inductive types on Props.  As part of this, we'll
need a form of equality for propositions that is called "if and only
if" or "double implication".

<div class="paragraph"> </div>

<pre>
Definition iff (A B:Prop) := (A -&gt; B) /\ (B -&gt; A).

Notation "A &lt;-&gt; B" := (iff A B) : type_scope.
</pre>

<div class="paragraph"> </div>

You should know everything you see in the proofs below.  Remember,
"simpl" is used to execute a function and "case" and "destruct" are
used on inductive types.

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">orb_is_or</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>, <span class="id" title="var">Is_true</span> (<span class="id" title="var">orb</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>) &lt;-&gt; <span class="id" title="var">Is_true</span> <span class="id" title="var">a</span> \/ <span class="id" title="var">Is_true</span> <span class="id" title="var">b</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">iff</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">conj</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
</div>

<div class="doc">
orb -&gt; \/ 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">a</span>, <span class="id" title="var">b</span>.<br/>
</div>

<div class="doc">
suppose a,b is true, true 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">or_introl</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>

<br/>
</div>

<div class="doc">
suppose a,b is true, false 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">or_introl</span> <span class="id" title="var">I</span>).<br/>

<br/>
</div>

<div class="doc">
suppose a,b is false, true 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">or_intror</span> <span class="id" title="var">I</span>).<br/>

<br/>
</div>

<div class="doc">
suppose a,b is false, false 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
\/ -&gt; orb 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">a</span>, <span class="id" title="var">b</span>.<br/>
</div>

<div class="doc">
suppose a,b is true, true 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>

<br/>
</div>

<div class="doc">
suppose a,b is true, false 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>

<br/>
</div>

<div class="doc">
suppose a,b is false, true 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>

<br/>
</div>

<div class="doc">
suppose a,b is false, false 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">H</span>.<br/>
</div>

<div class="doc">
suppose H is (or_introl A) 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
suppose H is (or_intror B) 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">B</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Wow!  We're not in Kansas any more!

<div class="paragraph"> </div>

First, I used "case" to split the "\/" hidden inside the "&lt;-&gt;".

<div class="paragraph"> </div>

Second, inside each of those branches, I did "case a,b", which created
4 subgoals, for every possible combination of the two constructors.  I
thought the proof was clearer that way, even though doing "case a"
followed by "case b" might have been shorter.

<div class="paragraph"> </div>

The proofs for when "a" or "b" were true were easy.  They were all the
same proof.  You can see that I make the proof shorter as I went along
<ul class="doclist">
<li> combining "refine" and "exact" and skipping right over "simpl".

</li>
</ul>

<div class="paragraph"> </div>

When both "a" and "b" were false, I decided it was best to do "case"
on an instance of False.  For "orb", that was pretty easy.  I did
"simpl in H", which executed functions calls inside a hypothesis.
That gave me an hypothesis of type False, and "case H" ended the
subgoal.

<div class="paragraph"> </div>

However, for the inductive type "or", it was more complicated.  I used
"case H" to consider the different ways of constructing the "or".
Both constructors - "or_introl" and "or_intror" - lead to a False
hypothesis.

<div class="paragraph"> </div>

That was a real proof.  Welcome to the big leagues.

<div class="paragraph"> </div>

<i>RULE</i> If a hypothesis "&lt;name&gt;" contain a function call with all its arguments,
      Then use the tactic "simpl in &lt;name&gt;.".

<div class="paragraph"> </div>

Let's try it with "andb" and "/\".

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_is_and</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>, <span class="id" title="var">Is_true</span> (<span class="id" title="var">andb</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>) &lt;-&gt; <span class="id" title="var">Is_true</span> <span class="id" title="var">a</span> /\ <span class="id" title="var">Is_true</span> <span class="id" title="var">b</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">iff</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">conj</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
</div>

<div class="doc">
andb -&gt; /\ 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">a</span>, <span class="id" title="var">b</span>.<br/>
</div>

<div class="doc">
suppose a,b is true,true 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">conj</span> <span class="id" title="var">I</span> <span class="id" title="var">I</span>).<br/>

<br/>
</div>

<div class="doc">
suppose a,b is true,false 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
suppose a,b is false,true 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
suppose a,b is false,false 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">
/\ -&gt; andb 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">a</span>,<span class="id" title="var">b</span>.<br/>
</div>

<div class="doc">
suppose a,b is true,true 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>

<br/>
</div>

<div class="doc">
suppose a,b is true,false 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [ <span class="id" title="var">A</span> <span class="id" title="var">B</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">B</span>.<br/>

<br/>
</div>

<div class="doc">
suppose a,b is false,true 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [ <span class="id" title="var">A</span> <span class="id" title="var">B</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">A</span>.<br/>

<br/>
</div>

<div class="doc">
suppose a,b is false,false 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">H</span> <span class="id" title="keyword">as</span> [ <span class="id" title="var">A</span> <span class="id" title="var">B</span>].<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">A</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab34"></a><h3 class="section">admit tactic</h3>

<div class="paragraph"> </div>

It should be easy for you to proof that "not" and "notb" are
equivalent.  Below is a statement of the theorem; fill it in
if you think you can.

<div class="paragraph"> </div>

I did not include a proof, so where you would normally see a proof,
you'll see the tactic "admit" and the vernacular command "Admitted".
The tactic "admit" is a cheat.  It ends a subgoal without solving it.
A proof containing an "admit" is not a real proof, so Coq forces you
to end it with "Admitted" instead of "Qed".  I use these commands
below so that Coq's parser won't get hung up because I didn't include
a proof of the theorem.

<div class="paragraph"> </div>

The "admit" tactic has real uses.  When there are multiple subgoals
and you want to skip over the easy ones to work on the hard one first,
the "admit" tactic can be used to get the easy subgoals out of the
way.  Or, if you are only part way done a proof but you want send
someone a Coq file that parses, "admit" can be used to fill in your
blanks.

<div class="paragraph"> </div>

So, take a swing at proving this theorem.
<ul class="doclist">
<li> HINT: Remember "~A" is "A -&gt; False".

</li>
<li> HINT: You can make use of the proof "False_cannot_be_proven"

</li>
<li> HINT: When you get stuck, look at "thm_true_imp_false".

</li>
</ul>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">negb_is_not</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">Is_true</span> (<span class="id" title="var">negb</span> <span class="id" title="var">a</span>) &lt;-&gt; (~(<span class="id" title="var">Is_true</span> <span class="id" title="var">a</span>))).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">admit</span>. </div>

<div class="doc">
delete "admit" and put your proof here. 
</div>
<div class="code">
<span class="id" title="var">Admitted</span>. </div>

<div class="doc">
when done, replace "Admitted." with "Qed." 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

<i>RULE</i>: If you have a subgoal that you want to ignore for a while,
      Then use the tactic "admit.".

<div class="paragraph"> </div>

<a name="lab35"></a><h1 class="section">Existence and Equality</h1>

<div class="paragraph"> </div>

Like "and" and "or", the concepts of "there exists" and "equality" are
not fundamental to Coq.  They are concepts defined inside of it. Only
"forall" and the notion of creating a type with constructors is
fundamental to Coq.

<div class="paragraph"> </div>

<a name="lab36"></a><h2 class="section">Existence</h2>

<div class="paragraph"> </div>

In Coq, you cannot just declare that something exists.  You must prove
it.

<div class="paragraph"> </div>

For example, we might want to prove that "there exists a bool 'a' such
that (Is_true (andb a true))".  We cannot just state that the
"bool" exists.  You need to produce a value for "a" - called the
witness - and then prove that the statement holds for the witness.

<div class="paragraph"> </div>

The definition and operator are:
<pre>
Inductive ex (A:Type) (P:A -&gt; Prop) : Prop :=
  ex_intro : forall x:A, P x -&gt; ex (A:=A) P.

Notation "'exists' x .. y , p" := (ex (fun x =&gt; .. (ex (fun y =&gt; p)) ..))
  (at level 200, x binder, right associativity,
   format "'[' 'exists'  '/  ' x  ..  y ,  '/  ' p ']'")
  : type_scope.
</pre>

<div class="paragraph"> </div>

The proposition "ex P" should be read: "P is a function returning a
Prop and there exists an argument to that function such that (P arg)
has been proven".  The function "P" is known as "the predicate".  The
constructor for "ex P" takes the predicate "P" , the witness (called
"x" here) and a proof of "P x" in order to return something of type
"ex P".

<div class="paragraph"> </div>

"exists ..., ..." is an operator to provide a friendly notation.  For
"and" and "or", we did the same with "/\" and "\/".  For existence,
the usually operator is a capital E written backwards, but that's
difficult to type, so Coq uses the word "exists".

<div class="paragraph"> </div>

Let's test this out with the easy theorem I already mentioned.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">basic_predicate</span><br/>
:=<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">a</span> =&gt; <span class="id" title="var">Is_true</span> (<span class="id" title="var">andb</span> <span class="id" title="var">a</span> <span class="id" title="var">true</span>))<br/>
.<br/>

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">thm_exists_basics</span> : (<span class="id" title="var">ex</span> <span class="id" title="var">basic_predicate</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">witness</span> := <span class="id" title="var">true</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">ex_intro</span> <span class="id" title="var">basic_predicate</span> <span class="id" title="var">witness</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

I start by defining the predicate: a function that takes a single
argument "a" (which Coq can determine is a "bool").  The key part of
the proof is the tactic "refine (ex_intro ...)". The arguments to
"ex_intro" are:
<ul class="doclist">
<li> the predicate

</li>
<li> the witness

</li>
<li> a proof of the predicated called with the witness

</li>
</ul>

<div class="paragraph"> </div>

In this usage, I passed "ex_intro" the predicate, the witness, and
use an "_" to create a new subgoal for the proof.  The tactics "simpl"
and "exist" are used to solve the proof.

<div class="paragraph"> </div>

I'll prove the same theorem, but this time I'll use "exists" operator
to show you how much cleaner it looks.

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">thm_exists_basics__again</span> : (<span class="id" title="tactic">exists</span> <span class="id" title="var">a</span>, <span class="id" title="var">Is_true</span> (<span class="id" title="var">andb</span> <span class="id" title="var">a</span> <span class="id" title="var">true</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">witness</span> := <span class="id" title="var">true</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">ex_intro</span> <span class="id" title="var">_</span> <span class="id" title="var">witness</span> <span class="id" title="var">_</span>).<br/>
</div>

<div class="doc">
Coq automatically determines the predicate!  We're left to prove that the witness satisfies the function. 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<i>RULE</i>: If the current subgoal starts "exists &lt;name&gt;, ..."
     Then create a witness and use "refine (ex_intro _ witness _)"

<div class="paragraph"> </div>

<a name="lab37"></a><h3 class="section">More existence</h3>

<div class="paragraph"> </div>

We often use "exists" and "forall" at the same time.  Thus, we end up
with proofs like the following.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">thm_forall_exists</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span>, (<span class="id" title="tactic">exists</span> <span class="id" title="var">a</span>, <span class="id" title="var">Is_true</span>(<span class="id" title="var">eqb</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>))).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">b</span>.<br/>
</div>

<div class="doc">
b is true 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">witness</span> := <span class="id" title="var">true</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">ex_intro</span> <span class="id" title="var">_</span> <span class="id" title="var">witness</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>

<br/>
</div>

<div class="doc">
b is false 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">witness</span> := <span class="id" title="var">false</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">ex_intro</span> <span class="id" title="var">_</span> <span class="id" title="var">witness</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">I</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
If you look at the proof above, the witness was always equal to "b".
So, let's try simplifying the proof.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">thm_forall_exists__again</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">b</span>, (<span class="id" title="tactic">exists</span> <span class="id" title="var">a</span>, <span class="id" title="var">Is_true</span>(<span class="id" title="var">eqb</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>))).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">ex_intro</span> <span class="id" title="var">_</span> <span class="id" title="var">b</span> <span class="id" title="var">_</span>). </div>

<div class="doc">
witness is b 
</div>
<div class="code">
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eqb_a_a</span> <span class="id" title="var">b</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
We used "b" as the witness and ended up with the state:

<div class="paragraph"> </div>

<pre>
  b : bool
  ============================
   Is_true (eqb b b)
</pre>

<div class="paragraph"> </div>

Now, we have already proved:
<pre>
Theorem eqb_a_a : (forall a : bool, Is_true (eqb a a)).
</pre>

<div class="paragraph"> </div>

I've told you that "-&gt;" is the type of a function and that "-&gt;" is
shorthand for "(forall ...)", so it's not a far leap to see that our
theorem "eqb_a_a" is a function from any bool (called "a" in the
statement) to a proof of "Is_true (eqb a a)".

<div class="paragraph"> </div>

In our current proof, we needed that statement to hold for our
particular hypothesis of "b".  That is done by the function call
"eqb_a_a b", which substitutes the specific "b" into the place of the
generic "a" in the body of the "forall".  The result is "Is_true (eqb
b b)", which solves our proof.

<div class="paragraph"> </div>

<a name="lab38"></a><h3 class="section">Exists and Forall</h3>

<div class="paragraph"> </div>

Here is a classic theorem of logic, showing the relationship between
"forall" and "exists".  It gives us a chance to "destruct" an instance
of type "ex".

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">forall_exists</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Set</span>-&gt;<span class="id" title="keyword">Prop</span>,  (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, ~(<span class="id" title="var">P</span> <span class="id" title="var">x</span>)) -&gt; ~(<span class="id" title="tactic">exists</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">forall_x_not_Px</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">exists_x_Px</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">exists_x_Px</span> <span class="id" title="keyword">as</span> [ <span class="id" title="var">witness</span> <span class="id" title="var">proof_of_Pwitness</span>].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">not_Pwitness</span> := <span class="id" title="var">forall_x_not_Px</span> <span class="id" title="var">witness</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> <span class="id" title="var">not_Pwitness</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">pose</span> (<span class="id" title="var">proof_of_False</span> := <span class="id" title="var">not_Pwitness</span> <span class="id" title="var">proof_of_Pwitness</span>).<br/>
&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">proof_of_False</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The proof requires some explanation.
<ul class="doclist">
<li> we use intros and unfold until we have everything in the context.

</li>
<li> we use "destruct" to extract the witness and the proof of "P witness".

</li>
<li> we call "(forall x, ~(P x))" with the witness, to generate "(P witness) -&gt; False"

</li>
<li> we call "P witness -&gt; False" with "P witness" to get a proof of "False".

</li>
<li> we use the tactic "case" on "proof_of_False"

</li>
</ul>

<div class="paragraph"> </div>

This proof is hard to read.  If you have difficulty reading a proof,
you can always use CoqIDE or Proof General to step through the proof
and look at the state after each tactic.

<div class="paragraph"> </div>

Another good example of "exists" is proving that the implication goes
the other way too.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">exists_forall</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">P</span> : <span class="id" title="keyword">Set</span>-&gt;<span class="id" title="keyword">Prop</span>,  ~(<span class="id" title="tactic">exists</span> <span class="id" title="var">x</span>, <span class="id" title="var">P</span> <span class="id" title="var">x</span>) -&gt; (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span>, ~(<span class="id" title="var">P</span> <span class="id" title="var">x</span>))).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">not_exists_x_Px</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">P_x</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span> <span class="id" title="tactic">in</span> <span class="id" title="var">not_exists_x_Px</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">not_exists_x_Px</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">ex_intro</span> <span class="id" title="var">P</span> <span class="id" title="var">x</span> <span class="id" title="var">P_x</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Again, this isn't a very readable proof.  It goes by:
<ul class="doclist">
<li> we use intros and unfold until our subgoal is "False".

</li>
<li> we use "refine" to call a function whose type ends in "-&gt; False"

</li>
<li> we create something of type "exists" by calling "ex_intro"

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab39"></a><h3 class="section">Calculating witnesses</h3>

<div class="paragraph"> </div>

For some predicates, the witness is a single value or is easy to
generate.  Other times, it isn't.  In those cases, we can write a
function to calculate the witness.

<div class="paragraph"> </div>

Right now, we can't write very complicated functions, since we only
know a few types.  When we have lists and natural numbers, you'll see
some examples.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab40"></a><h2 class="section">Equality</h2>

<div class="paragraph"> </div>

Now we come to the big prize: equality!  Equality is a derived concept
in Coq.  It's an inductive type, just like "and", "or", and "ex"
("exists").  When I found that out, I was shocked and fascinated!

<div class="paragraph"> </div>

It's defined as:
<pre>
Inductive eq (A:Type) (x:A) : A -&gt; Prop :=
    eq_refl : x = x :&gt;A

where "x = y :&gt; A" := (@eq A x y) : type_scope.

Notation "x = y" := (x = y :&gt;_) : type_scope.
</pre>

<div class="paragraph"> </div>

The "Inductive" statement creates a new type "eq" which is a function
of a type A and 2 values of type A to Prop.  (NOTE: One value of type
A is written (x:A) before the ":" and the other is written "A -&gt;"
after.  This is done so Coq infers the type "A" from the first
value and not the second.)  Calling "eq" with all its arguments
returns a proposition (with type Prop).  A proof of "eq x y" means
that "x" and "y" both have the same type and that "x" equals "y".

<div class="paragraph"> </div>

The only way to create a proof of type "eq" is to use the only
constructor "eq_refl".  It takes a value of "x" of type "A" and
returns "@eq A x x", that is, that "x" is equal to itself.  (The "@"
prevents Coq from inferring values, like the type "A".)  The name
"eq_refl" comes from the reflexive property of equality.

<div class="paragraph"> </div>

Lastly, comes two operators.  The less commonly used one is "x = y :&gt;
A" which let's you say that "x" and "y" are equal and both have type
"A".  The one you'll use most of the time, "x = y", does the same but
let's Coq infer the type "A" instead of forcing you to type it.

<div class="paragraph"> </div>

Now, if you we paying attention, you saw that "eq_refl" is the only
constructor.  We can only create proofs of "x = x"!  That doesn't seem
useful at all!

<div class="paragraph"> </div>

What you don't see is that Coq allows you to execute a function call
and substitute the result for the function call.  For example, if we had
a function "plus" that added natural numbers (which have type "nat"),
we could use "eq_refl (plus 1 1)" to create a proof of
"eq nat (plus 1 1) (plus 1 1)".  Then, if we execute the second function
call, we get "eq nat (plus 1 1) 2", that is, "1 + 1 = 2"!

<div class="paragraph"> </div>

The concept of substituting a function call with its result or
substituting the result with the function call is called
"convertibility".  One tactic we've seen, "simpl", replaces
convertible values.  We'll see more tactics in the future.

<div class="paragraph"> </div>

Now that we have a concept of what "=" means in Coq, let's use it!

<div class="paragraph"> </div>

<a name="lab41"></a><h3 class="section">Equality is symmetric</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">thm_eq_sym</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> : <span class="id" title="keyword">Set</span>, <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">y</span> = <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x_y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x_y</span> <span class="id" title="keyword">as</span> [].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
I use the "destruct" tactic on the type "eq" because it only has one
constructor.  Let's look at the state before and after that call.

<div class="paragraph"> </div>

Before, it is:
<pre>
  x : Set
  y : Set
  x_y : x = y
  ============================
   y = x
</pre>

<div class="paragraph"> </div>

And after:
<pre>
  x : Set
  ============================
   x = x
</pre>

<div class="paragraph"> </div>

By destructing the "eq_refl", Coq realizes that "x" and "y" are
convertible and wherever the second name is, it can be replaced by
the first.  So, "y" disappears and is replaced by "x".  (NOTE:
"destruct" unlike "case", does change the context, so the hypotheses
"y" and "x_y" also disappear.)

<div class="paragraph"> </div>

After "destruct", we're left with a subgoal of "x = x", which is
solved by calling "eq_refl".

<div class="paragraph"> </div>

Just to become familiar, let's prove the other big property of
equality: transitivity.

<div class="paragraph"> </div>

<a name="lab42"></a><h3 class="section">Equality is transitive</h3>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">thm_eq_trans</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>: <span class="id" title="keyword">Set</span>, <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">y</span> = <span class="id" title="var">z</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">z</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x_y</span> <span class="id" title="var">y_z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">x_y</span> <span class="id" title="keyword">as</span> [].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">y_z</span> <span class="id" title="keyword">as</span> [].<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Seems pretty easy, doesn't it?

<div class="paragraph"> </div>

Rather than using "destruct", most proofs using equality use the
tactics "rewrite" and "rewrite &lt;-".  If "x_y" has type "x = y", then
"rewrite x_y" will replace "x" with "y" in the subgoal and "rewrite &lt;-
x_y" will go the other way, replacing "y" with "x".

<div class="paragraph"> </div>

Let's see these tactics by proving transitivity again.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">thm_eq_trans__again</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>: <span class="id" title="keyword">Set</span>, <span class="id" title="var">x</span> = <span class="id" title="var">y</span> -&gt; <span class="id" title="var">y</span> = <span class="id" title="var">z</span> -&gt; <span class="id" title="var">x</span> = <span class="id" title="var">z</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x_y</span> <span class="id" title="var">y_z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">x_y</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">y_z</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">y</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
That is much cleaner.

<div class="paragraph"> </div>

<i>RULE</i>: If you have a hypothesis "&lt;name&gt; : &lt;a&gt; = &lt;b&gt;"
     AND "&lt;a&gt;" in your current subgoal
     Then use the tactic "rewrite &lt;name&gt;.".

<div class="paragraph"> </div>

<i>RULE</i>: If you have a hypothesis "&lt;name&gt; : &lt;a&gt; = &lt;b&gt;"
     AND "&lt;b&gt;" in your current subgoal
     Then use the tactic "rewrite &lt;- &lt;name&gt;.".

<div class="paragraph"> </div>

Let's try something that explicitly relies on convertibility.  Recall,
"andb" is and for "bools" and that it is represented by the operator
"&amp;&amp;".

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">andb_sym</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>, <span class="id" title="var">a</span> &amp;&amp; <span class="id" title="var">b</span> = <span class="id" title="var">b</span> &amp;&amp; <span class="id" title="var">a</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">a</span>, <span class="id" title="var">b</span>.<br/>
</div>

<div class="doc">
suppose a,b is true,true 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">true</span>).<br/>

<br/>
</div>

<div class="doc">
suppose a,b is true,false 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">false</span>).<br/>

<br/>
</div>

<div class="doc">
suppose a,b is false,true 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">false</span>).<br/>

<br/>
</div>

<div class="doc">
suppose a,b is false,false 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">false</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
So, for this proof, we divided it into 4 cases and used convertibility
to show that equality held in each.  Pretty simple.

<div class="paragraph"> </div>

I should do an example with inequality too.

<div class="paragraph"> </div>

<a name="lab43"></a><h3 class="section">Inequality with discriminate</h3>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Coq uses the operator "&lt;&gt;" for inequality, which really means
"equality is unprovable" or "equality implies False".

<div class="paragraph"> </div>

<pre>
Notation "x &lt;&gt; y  :&gt; T" := (~ x = y :&gt;T) : type_scope.
Notation "x &lt;&gt; y" := (x &lt;&gt; y :&gt;_) : type_scope.
</pre>

<div class="paragraph"> </div>

Let's start with a simple example.  Recall that "negb" is the
"not" operation for bools.

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">neq_nega</span>: (<span class="id" title="keyword">forall</span> <span class="id" title="var">a</span>, <span class="id" title="var">a</span> &lt;&gt; (<span class="id" title="var">negb</span> <span class="id" title="var">a</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">case</span> <span class="id" title="var">a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a_eq_neg_a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">a_eq_neg_a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">discriminate</span> <span class="id" title="var">a_eq_neg_a</span>.<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">a_eq_neg_a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">a_eq_neg_a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">discriminate</span> <span class="id" title="var">a_eq_neg_a</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
To prove this, once again I had to delay calling "intros" until after
"case".  If I did not, "a" in "a_eq_neg_a" would not get replaced
"true" or "false".  I also used a new tactic: "discriminate".

<div class="paragraph"> </div>

"discriminate" operates on a hypothesis where values of inductive type
are compared using equality.  If the constructors used to generate the
type are the different, like here where we have "true = false", then
Coq knows that situation can never happen.  It's like a proof of
False.  In that case, "discriminate &lt;hypname&gt;." ends the subgoal.

<div class="paragraph"> </div>

When working with inductive types, you will use "discriminate" to
eliminate a lot of cases that can never happen.

<div class="paragraph"> </div>

<i>RULE</i>: If you have a hypothesis
          "&lt;name&gt; : (&lt;constructor1&gt; ...) = (&lt;constructor2&gt; ...)
     OR "&lt;name&gt; : &lt;constant1&gt; = &lt;constant2&gt;
     Then use the tactic "discriminate &lt;name&gt;.".

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

To really show off equality, we'll need something more numerous than
just 2 booleans.  Next up is natural numbers - an infinite set of
objects - and induction - which allows us to prove properties about
infinite sets of objects!

<div class="paragraph"> </div>

<a name="lab44"></a><h1 class="section">Natural Numbers and Induction</h1>
<a name="lab45"></a><h2 class="section">Peano Arithmetic</h2>

<div class="paragraph"> </div>

The natural numbers are 0, 1, 2, 3, 4, ... .  They are the simplest
mathematical concept that contain an unbounded number of values.

<div class="paragraph"> </div>

In 1889, Peano published a simple set of axioms (fundamental rules)
that defined the natural numbers and how to prove things about them.
Peano's axioms have become the standard way in logic of talking about
and manipulating the natural numbers.  More complex schemes - like the
decimal numbers we usually use - are justified by proving them
equivalent to Peano's axioms.

<div class="paragraph"> </div>

Peano's definition of natural numbers is:
<ul class="doclist">
<li> 0 is a natural number.

</li>
<li> For every natural number n, (S n) is a natural number.

</li>
</ul>

<div class="paragraph"> </div>

"(S n)" is spoken as "the successor of n" but you should think about
it as "1 + n".  If we were to list the first few of Peano's natural
numbers, they would be:
<ul class="doclist">
<li> 0 is 0

</li>
<li> 1 is (S 0) = (1 + 0)

</li>
<li> 2 is (S (S 0)) = (1+ (1 + 0))

</li>
<li> 3 is (S (S (S 0)) = (1 + (1 + (1 + 0)))

</li>
<li> ...

</li>
</ul>

<div class="paragraph"> </div>

Peano's natural numbers are represented in Coq by the type "nat".

<div class="paragraph"> </div>

<pre>
Inductive nat : Set :=
  | O : nat
  | S : nat -&gt; nat.
</pre>

<div class="paragraph"> </div>

<i>WARNING</i>: The "O" here is the capital-letter O, <i>not</i> the number zero.

<div class="paragraph"> </div>

So, Coq's natural numbers exactly matches the definition of Peano.

<div class="paragraph"> </div>

If we want to do something with "nat"s, we need some functions.  Here
is how Peano's definition of addition looks in Coq.

<div class="paragraph"> </div>

<pre>
Fixpoint plus (n m:nat) : nat :=
  match n with
  | O =&gt; m
  | S p =&gt; S (p + m)
  end

where "n + m" := (plus n m) : nat_scope.
</pre>

<div class="paragraph"> </div>

Previously, we used the vernacular command "Definition" to define a
function.  The command here is "Fixpoint".  "Fixpoint" must be used
any time you define a recursive function.  It's hard to see that
"plus" calls itself because the recursive call is hidden by the "+" in
"p + m".

<div class="paragraph"> </div>

We know that (2 + 3) = 5, so let's see how that property holds in Coq.
Below, the difference between lines is one execution of a function
call to "plus".

<div class="paragraph"> </div>

<ul class="doclist">
<li>       (plus (S (S O)) (S (S (S O))))

</li>
<li>    (S (plus    (S O)  (S (S (S O)))))

</li>
<li> (S (S (plus       O   (S (S (S O))))))

</li>
<li> (S (S (S (S (S O))))))

</li>
</ul>

<div class="paragraph"> </div>

Each execution of "plus" strips an "S" off the front of the first
number and puts it in front of the recursive call to "plus".  When the
first parameter is "O", "plus" returns the second argument.

<div class="paragraph"> </div>

Remember that "O" and "S" are constructors - they're opaque functions
that were created when we declared "nat".  There is no way to execute
them.  Therefore, "(S (S (S (S (S O))))))" does not have any function
calls that can be executed and, therefore, is the canonical form of
the number 5.

<div class="paragraph"> </div>

The proof of "2 + 3 = 5" only need one call to "simpl" to get it to
the canonical form.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_2_3</span> : (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>)) + (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>))) = (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> (<span class="id" title="var">S</span> <span class="id" title="var">O</span>))))).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> 5).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
As you can see by "eq_refl 5", Coq will translate decimal numbers into
terms of "nat" automatically.  This means capital-letter "O" and the
digit "0" are really the same term, which prevents a lot of mistakes.
There are ways to instruct Coq to treat decimals as other types, such
as integers, rationals, etc.

<div class="paragraph"> </div>

We can convince ourselves that the function "plus" has all the
properties associated with addition, by proving those properties.  So,
let's prove them!

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_O_n</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>, <span class="id" title="var">O</span> + <span class="id" title="var">n</span> = <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab46"></a><h2 class="section">Induction</h2>

<div class="paragraph"> </div>

It was easy to prove "(forall n, O + n = n)", but it's much harder to
prove "(forall n, n + O = n)".  The reason is that the function "plus"
executes "match" on its first parameter.  If the first parameter is a
constant, such as "O", we can use "simpl" to execute "plus" and get
the answer.  But, if the first argument is a variable, like "n", we
can't.

<div class="paragraph"> </div>

To solve this, we need to do the proof by induction on "n".  Peano's
axiom for induction is:
<pre>
  If "P" is a predicate such that
     (P 0) is proven, and
     for all n, (P n) -&gt; (P (S n)) is proven,
  Then (P n) is proven for all n.
</pre>

<div class="paragraph"> </div>

The proof of "(P O)" is known as the "base case".  The proof of
"(forall n:nat, P n -&gt; P (S n))" is known as the "inductive case" and,
inside that case, "P n" is known as the "inductive hypothesis".

<div class="paragraph"> </div>

When "nat" was declared, Coq created a function that exactly
represents induction on "nat"s.  It is called "nat_ind" and you can
see its type with the vernacular command "Check".

</div>
<div class="code">
<span class="id" title="keyword">Check</span> <span class="id" title="var">nat_ind</span>.<br/>
</div>

<div class="doc">
Its output should look like this:
<pre>
nat_ind
     : forall P : nat -&gt; Type,
         P O -&gt; (forall n : nat, P n -&gt; P (S n)) -&gt; forall n : nat, P n
</pre>

<div class="paragraph"> </div>

Now, we <i>could</i>
  - define a function "P n" that represents "O + n = n"
<ul class="doclist">
<li> prove that the function holds for "P O"

</li>
<li> prove that the function holds for "P (S n)" assuming "P n"

</li>
<li> and then call the function nat_ind with those 3 values.

</li>
</ul>

<div class="paragraph"> </div>

But that's a lot of work.  Luckily, Coq defines tactics that do most
of the work for us!  These tactics take a subgoal and infer the
predicate P, and then generates child subgoals for the other pieces.

<div class="paragraph"> </div>

One tactic, "elim" works very similarly to "case".

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_n_O</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>, <span class="id" title="var">n</span> + <span class="id" title="var">O</span> = <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">elim</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
base case 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">O</span>).<br/>

<br/>
</div>

<div class="doc">
inductive case 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">inductive_hypothesis</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">inductive_hypothesis</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>)).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
It's obvious how the tactic "elim" generates the base case and
inductive case.  It was important to me to show that the "n" in the
inductive case was different from the original "n" in our goal.  I
chose to name it "n'" which is spoken "n prime".

<div class="paragraph"> </div>

I used the "rewrite" tactic with the inductive hypothesis to
substitute "n' + O" in the subgoal.  If you're using the "elim"
tactic, you should always use the inductive hypothesis.  If you don't,
you should use the "case" tactic instead of "elim".

<div class="paragraph"> </div>

<i>RULE</i>: If there is a hypothesis "&lt;name&gt;" of a created type
     AND that hypothesis is used in the subgoal,
     AND the type has a recursive definition,
     Then you can try the tactic "elim &lt;name&gt;.".

</div>
<div class="code">

<br/>
</div>

<div class="doc">
<a name="lab47"></a><h3 class="section">Induction tactic</h3>

<div class="paragraph"> </div>

Just as the "case" tactic has a similar "destruct" tactic, the "elim"
tactic has a similar "induction" tactic.  Let's look at the previous
proof, but using this new tactic.

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_n_O__again</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span>, <span class="id" title="var">n</span> + <span class="id" title="var">O</span> = <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">induction</span> <span class="id" title="var">n</span> <span class="id" title="keyword">as</span> [|<span class="id" title="var">n'</span> <span class="id" title="var">inductive_hypothesis</span>].<br/>
</div>

<div class="doc">
base case 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">O</span>).<br/>

<br/>
</div>

<div class="doc">
inductive case 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">inductive_hypothesis</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>)).<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
So, the "induction" tactic does the same thing as "elim.", except the
names of the created variables are listed in the tactic, rather than
being assigned later using "intros" in the inductive case of the proof.

<div class="paragraph"> </div>

The "induction" command creates 2 subgoals, one for the base case and
another for the inductive case, and after the "as" keyword, there are
2 lists of variable names, one for the base case and one for the
inductive case.  Those lists are separated by verical bars ('|')
inside the square brackets.  The base case doesn't create any
variables, so its list is empty.  The inductive case creates two
variables, and they are named "n'" and "inductive_hypothesis".

<div class="paragraph"> </div>

I said the "induction" command was similar to "destruct" and, if the
type "destruct"ed has more than one constructor, the "destruct"
command will create a subgoals for each constructor and the command
needs a list of variable names for each constructor.  For example, the
type "or" has two constructors.  Recall that something of type "or A
B" can be created by "or_introl proof_of_A" or "or_intror proof_of_B".
If I "destruct" an "or A B", it will create two subgoals and the
"destruct" needs to have a list of variables for each.  To
demonstrate this, I'll redo the proof that or commutes.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">or_commutes__again</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>, <span class="id" title="var">A</span> \/ <span class="id" title="var">B</span> -&gt; <span class="id" title="var">B</span> \/ <span class="id" title="var">A</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span> <span class="id" title="var">B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A_or_B</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">destruct</span> <span class="id" title="var">A_or_B</span> <span class="id" title="keyword">as</span> [<span class="id" title="var">proof_of_A</span> | <span class="id" title="var">proof_of_B</span>].<br/>
</div>

<div class="doc">
suppose A_or_B is (or_introl proof_of_A) 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">or_intror</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_A</span>.<br/>

<br/>
</div>

<div class="doc">
suppose A_or_B is (or_intror proof_of_B) 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">or_introl</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> <span class="id" title="var">proof_of_B</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
In my proofs, I like to use "case" and "elim" and only use "destruct"
for types with a single constructor.  However, some people prefer to
use "destruct" and "induction" for every proof.  The writers of Coq
are talking about removing this duplication and may remove "case" and
"elim" in the future.

<div class="paragraph"> </div>

If you want to use "destruct" and "induction", it is helpful to use
the Vernacular command "Print", which prints out a definition and
shows you how many constructors there are and which variables you need
to name for each one.

</div>
<div class="code">
<span class="id" title="keyword">Print</span> <span class="id" title="var">or</span>.<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">nat_ind</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Now we return to proofs on induction using "nat".  And let's do a
difficult proof.  Let's prove that "n + m = m + n".
<a name="lab48"></a><h3 class="section">Addition is Symmetric</h3>

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">plus_sym</span>: (<span class="id" title="keyword">forall</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>, <span class="id" title="var">n</span> + <span class="id" title="var">m</span> = <span class="id" title="var">m</span> + <span class="id" title="var">n</span>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n</span> <span class="id" title="var">m</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">elim</span> <span class="id" title="var">n</span>.<br/>
</div>

<div class="doc">
base case for n 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">elim</span> <span class="id" title="var">m</span>.<br/>
</div>

<div class="doc">
base case for m 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> (<span class="id" title="var">O</span> + <span class="id" title="var">O</span>)).<br/>

<br/>
</div>

<div class="doc">
inductive case for m 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">m'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">inductive_hyp_m</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> &lt;- <span class="id" title="var">inductive_hyp_m</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> (<span class="id" title="var">S</span> <span class="id" title="var">m'</span>)).<br/>

<br/>
</div>

<div class="doc">
inductive case for n 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">n'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">inductive_hyp_n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">inductive_hyp_n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">elim</span> <span class="id" title="var">m</span>.<br/>
</div>

<div class="doc">
base case for m 
</div>
<div class="code">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> (<span class="id" title="var">S</span> <span class="id" title="var">n'</span>)).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">m'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">inductive_hyp_m</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">rewrite</span> <span class="id" title="var">inductive_hyp_m</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> (<span class="id" title="var">S</span> (<span class="id" title="var">m'</span> + <span class="id" title="var">S</span> <span class="id" title="var">n'</span>))).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
That is a <i>hard</i> proof.  I've seen an expert in Coq get stuck on it
for 10 minutes.  It uses a lot of the features that I've demonstrated
in this tutorial.  I encourage you to open a new file and try to prove
it yourself.  If you get stuck on part of it, you should use the "admit" tactic
and move onto another part.  If you get really stuck, open up this
file and look at how I did it in my proof.  You should keep practicing
on that proof until you can do it automatically.

<div class="paragraph"> </div>

<a name="lab49"></a><h3 class="section">Common nat operators</h3>

<div class="paragraph"> </div>

"nat" is a commonly used type in Coq and there are a lot of operators
defined for it.  Having seen how "plus" was defined, you can probably
guess the definition for "mult".

<div class="paragraph"> </div>

<pre>
Fixpoint mult (n m:nat) : nat :=
  match n with
  | O =&gt; 0
  | S p =&gt; m + p * m
  end

where "n * m" := (mult n m) : nat_scope.
</pre>

<div class="paragraph"> </div>

Also defined are:
<ul class="doclist">
<li> "n - m" := (minus n m)

</li>
<li> "n &lt;= m" := (le n m)

</li>
<li> "n &lt;  m" := (lt n m)

</li>
<li> "n &gt;= m" := (ge n m)

</li>
<li> "n &gt;  m" := (gt n m)

</li>
</ul>

<div class="paragraph"> </div>

Along with:
<ul class="doclist">
<li> "x &lt;= y &lt;= z" := (x &lt;= y /\ y &lt;= z)

</li>
<li> "x &lt;= y &lt; z"  := (x &lt;= y /\ y &lt;  z)

</li>
<li> "x &lt; y &lt; z"   := (x &lt;  y /\ y &lt;  z)

</li>
<li> "x &lt; y &lt;= z"  := (x &lt;  y /\ y &lt;= z)

</li>
<li> "max n m"

</li>
<li> "min n m"

</li>
</ul>

<div class="paragraph"> </div>

The dangerous one in this group is "minus".  The natural numbers don't
go lower than 0, so "(1 - 2)" cannot return a negative number.  Since
Coq must return something of type "nat", it returns "O" instead.  So
you can do crazy proofs like this without intending!

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">minus_is_funny</span> : (0 - 1) = (0 - 2).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> 0).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
Later, with lists, I'll show you different ways to implement "minus"
without this flaw.

<div class="paragraph"> </div>

<a name="lab50"></a><h1 class="section">Data types</h1>

<div class="paragraph"> </div>

You've learned the basics of Coq.  This section introduces some
commonly used data types, so that you get to see them and get some
more experience reading proofs.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="var">List</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab51"></a><h2 class="section">Lists and Option</h2>

<div class="paragraph"> </div>

Lists are a common data structure in functional programming.
(Imperative programs use more arrays.)  The definition of a
singly-linked list in Coq is:

<div class="paragraph"> </div>

<pre>
Inductive list (A : Type) : Type :=
 | nil : list A
 | cons : A -&gt; list A -&gt; list A.
</pre>

<div class="paragraph"> </div>

I'll address the type "Type" in a second, but for the moment know that
a list takes a type called "A" and is either empty - constructed using
"nil" - or a node containing a value of type "A" and a link to another
list.

<div class="paragraph"> </div>

In a number of earlier places, I've ignored the type "Type".  It hides
some magic in Coq.  We saw early on that "proof_of_A" was a proof
and had type "A", which was a proposition.  "A", since it was a
proposition, had type "Prop".  But if types can have types, what type
does "Prop" have?  The answer is "Type(1)".  The answer to your next N
questions is that "Type(1)" has type "Type(2)".  "Type(2)" has type
"Type(3)".  Etc.

<div class="paragraph"> </div>

Similarly, "true" had type "bool".  "bool" had type "Set".  And "Set" has
type "Type(1)" (just like "Prop").

<div class="paragraph"> </div>

Coq hides this infinite hierarchy from the user with the magic type
"Type".  When you use "Type", Coq will determine if the value lies in
"Prop", "Set", or any of the the "Type(...)" types.

<div class="paragraph"> </div>

Going back to lists, there is an operator for building a list.
<pre>
Infix "::" := cons (at level 60, right associativity) : list_scope.
</pre>
So, the value "5 :: 4 :: nil" would be a "list nat" containing the
values 5 and 4.

<div class="paragraph"> </div>

A simple function that works on all types of lists is "length":
<pre>
Definition length (A : Type) : list A -&gt; nat :=
  fix length l :=
  match l with
   | nil =&gt; O
   | _ :: l' =&gt; S (length l')
  end.
</pre>

<div class="paragraph"> </div>

Just to get started, let's prove that adding an element to a list
increases it's length by 1.

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">cons_adds_one_to_length</span> :<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span>:<span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">lst</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">length</span> (<span class="id" title="var">x</span> :: <span class="id" title="var">lst</span>) = (<span class="id" title="var">S</span> (<span class="id" title="var">length</span> <span class="id" title="var">lst</span>)))).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">lst</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> (<span class="id" title="var">S</span> (<span class="id" title="var">length</span> <span class="id" title="var">lst</span>))).<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The proof is pretty simple, but the statement of what we want to prove
is not!  First, we need "A", which is the type stored in our lists.
Then we need an instance of A and a instance of a list of A.  Only
then can we state that putting an element on the front of a list
increases its length by 1.

<div class="paragraph"> </div>

<a name="lab52"></a><h3 class="section">The three forms of hd</h3>

<div class="paragraph"> </div>

Now, the simplest function you can imagine for a linked list is "hd",
which returns the first value in the list.  But there's a problem:
what should we return if the list is empty?

<div class="paragraph"> </div>

In some programming languages, you might throw an exception - either
explicitly or through a memory violation.  In others, you might assume
the program crashes.  But if you to prove a program correct, these
aren't choices you can make.  The program needs to be predictable.

<div class="paragraph"> </div>

There are choices you can make:
<ul class="doclist">
<li> have "hd" take an additional parameter, which it returns if the list is empty

</li>
<li> have "hd" return a new data structure that may or may not contain the value

</li>
<li> pass "hd" a proof that the list is not empty

</li>
</ul>

<div class="paragraph"> </div>

You didn't think of that last one, did you?!  I'll show you each of these
approaches so that you can see what they look like.
<a name="lab53"></a><h4 class="section">hd with additional parameter</h4>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">hd</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">default</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>)<br/>
:=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">default</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> :: <span class="id" title="var">_</span> =&gt; <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
This is the default version of hd in Coq and it looks like you would
expect.  This version is more useful than you might think thanks to
"partial evaluation".

<div class="paragraph"> </div>

"partial evaluation" is passing only <i>some</i> of the arguments to a
function.  In Coq, and many functional languages, the result is a new
function where the supplied arguments are now treated like constants
in the function and the remaining parameters are can still be passed
in.

<div class="paragraph"> </div>

Thus, we can do:

</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">my_hd_for_nat_lists</span><br/>
:=<br/>
&nbsp;&nbsp;<span class="id" title="var">hd</span> <span class="id" title="var">nat</span> 0.<br/>
</div>

<div class="doc">
The remaining parameter - the list - can still be passed to
"my_hd_for_nat_lists", but the "Type" parameter has been bound to
"nat" and the parameter "default" has been bound to zero.

<div class="paragraph"> </div>

We can confirm that it works correctly by using the vernacular command
"Compute", which executes all the function calls and prints the result.

</div>
<div class="code">
<span class="id" title="keyword">Compute</span> <span class="id" title="var">my_hd_for_nat_lists</span> <span class="id" title="var">nil</span>.<br/>
</div>

<div class="doc">
Prints "= 0 : nat".

</div>
<div class="code">
<span class="id" title="keyword">Compute</span> <span class="id" title="var">my_hd_for_nat_lists</span> (5 :: 4 :: <span class="id" title="var">nil</span>).<br/>
</div>

<div class="doc">
Prints "= 5 : nat".

<div class="paragraph"> </div>

We can also prove it correct.

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">correctness_of_hd</span> :<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span>:<span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">default</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">lst</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="var">hd</span> <span class="id" title="var">A</span> <span class="id" title="var">default</span> <span class="id" title="var">nil</span>) = <span class="id" title="var">default</span> /\ (<span class="id" title="var">hd</span> <span class="id" title="var">A</span> <span class="id" title="var">default</span> (<span class="id" title="var">x</span> :: <span class="id" title="var">lst</span>)) = <span class="id" title="var">x</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">default</span> <span class="id" title="var">x</span> <span class="id" title="var">lst</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">conj</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">default</span>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab54"></a><h4 class="section">hd returns option</h4>

<div class="paragraph"> </div>

The second approach is to have "hd" return another data structure that
either contains the first value in the list or contains nothing.  Coq
defines a generic data structure for that, called "option".

<div class="paragraph"> </div>

<pre>
Inductive option (A : Type) : Type :=
  | Some : A -&gt; option A
  | None : option A.
</pre>

<div class="paragraph"> </div>

"option" is a type with two constructors.  "Some" takes a value and
"None" does not.  To get the value out of an "option", a proof will
have to branch using "case" and look at the branch for the constructor
"Some".  Likewise, a program will have to use "match" and look at the
branch for "Some".

<div class="paragraph"> </div>

Coq includes a version of "hd" that returns an "option".  It's called
"hd_error".

</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">hd_error</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>)<br/>
:=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">None</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> :: <span class="id" title="var">_</span> =&gt; <span class="id" title="var">Some</span> <span class="id" title="var">x</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
Again, using "Compute" we can examine what it returns.

</div>
<div class="code">
<span class="id" title="keyword">Compute</span> <span class="id" title="var">hd_error</span> <span class="id" title="var">nat</span> <span class="id" title="var">nil</span>.<br/>
</div>

<div class="doc">
Prints "= None : option nat".

</div>
<div class="code">
<span class="id" title="keyword">Compute</span> <span class="id" title="var">hd_error</span> <span class="id" title="var">nat</span> (5 :: 4 :: <span class="id" title="var">nil</span>).<br/>
</div>

<div class="doc">
Prints "= Some 5 : option nat".

<div class="paragraph"> </div>

We can also prove it correct.

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">correctness_of_hd_error</span> :<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span>:<span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">lst</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="var">hd_error</span> <span class="id" title="var">A</span> <span class="id" title="var">nil</span>) = <span class="id" title="var">None</span> /\ (<span class="id" title="var">hd_error</span> <span class="id" title="var">A</span> (<span class="id" title="var">x</span> :: <span class="id" title="var">lst</span>)) = <span class="id" title="var">Some</span> <span class="id" title="var">x</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">lst</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">conj</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">None</span>).<br/>

<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> (<span class="id" title="var">Some</span> <span class="id" title="var">x</span>)).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab55"></a><h4 class="section">hd with a proof that the list is non-empty</h4>

<div class="paragraph"> </div>

Here's the option that's not available to any other programming
language you've seen: we can pass to "hd" a proof that the list is not
empty, so "hd" can never fail.

</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">hd_never_fail</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">lst</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>) (<span class="id" title="var">safety_proof</span> : <span class="id" title="var">lst</span> &lt;&gt; <span class="id" title="var">nil</span>)<br/>
&nbsp;&nbsp;: <span class="id" title="var">A</span><br/>
:=<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">match</span> <span class="id" title="var">lst</span> <span class="id" title="keyword">as</span> <span class="id" title="var">b</span> <span class="id" title="keyword">return</span> (<span class="id" title="var">lst</span> = <span class="id" title="var">b</span> -&gt; <span class="id" title="var">A</span>) <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt;    (<span class="id" title="keyword">fun</span> <span class="id" title="var">foo</span> : <span class="id" title="var">lst</span> = <span class="id" title="var">nil</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> (<span class="id" title="var">safety_proof</span> <span class="id" title="var">foo</span>) <span class="id" title="keyword">return</span> <span class="id" title="var">A</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">x</span> :: <span class="id" title="var">_</span> =&gt; (<span class="id" title="keyword">fun</span> <span class="id" title="var">foo</span> : <span class="id" title="var">lst</span> = <span class="id" title="var">x</span> :: <span class="id" title="var">_</span> =&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">x</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>) <span class="id" title="var">eq_refl</span>.<br/>

<br/>
</div>

<div class="doc">
I don't expect you to understand this function, let alone write
it.  It took me 30 minutes to write it, mostly by copying from code
printed using "Show Proof." from the complicated proofs above.

<div class="paragraph"> </div>

But I do expect you to understand that it <i>can</i> be written in Coq.
And, I expect you to be able to read a proof that the function does
what I said it does.

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">correctness_of_hd_never_fail</span> :<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span>:<span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">rest</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">exists</span> <span class="id" title="var">safety_proof</span> : ((<span class="id" title="var">x</span> :: <span class="id" title="var">rest</span>) &lt;&gt; <span class="id" title="var">nil</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">hd_never_fail</span>  <span class="id" title="var">A</span> (<span class="id" title="var">x</span> :: <span class="id" title="var">rest</span>) <span class="id" title="var">safety_proof</span>) = <span class="id" title="var">x</span>))).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">x</span> <span class="id" title="var">rest</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">assert</span> (<span class="id" title="var">witness</span> : ((<span class="id" title="var">x</span> :: <span class="id" title="var">rest</span>) &lt;&gt; <span class="id" title="var">nil</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">unfold</span> <span class="id" title="var">not</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">cons_eq_nil</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">discriminate</span> <span class="id" title="var">cons_eq_nil</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">refine</span> (<span class="id" title="var">ex_intro</span> <span class="id" title="var">_</span> <span class="id" title="var">witness</span> <span class="id" title="var">_</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> <span class="id" title="var">x</span>).<br/>
<span class="id" title="keyword">Qed</span>.<br/>
</div>

<div class="doc">
The proof is pretty simple.  We create a witness for the exists.
Since the witness involves an inequality, we end its proof with
"discriminate".  Then we use "simpl" to show that the function returns
what the right value.

<div class="paragraph"> </div>

In this proof, I used the tactic "assert" instead of "pose".  I wanted
to write:
<pre>
  pose (witness := _ : ((x :: rest) &lt;&gt; nil)).
</pre>
But Coq does not allow that for some reason.  "pose" cannot have "_"
for the complete value.  If you want to use "_" for the whole value of
pose, you have to use the tactic "assert".

<div class="paragraph"> </div>

<a name="lab56"></a><h3 class="section">Tail of lists</h3>

<div class="paragraph"> </div>

"hd" extracts the first value in a list and its partner "tl" returns
the list after that first element.  In Coq, it's definition is:

</div>
<div class="code">
<span class="id" title="keyword">Definition</span> <span class="id" title="var">tl</span> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">l</span>:<span class="id" title="var">list</span> <span class="id" title="var">A</span>) :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <span class="id" title="var">l</span> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">nil</span> =&gt; <span class="id" title="var">nil</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;| <span class="id" title="var">a</span> :: <span class="id" title="var">m</span> =&gt; <span class="id" title="var">m</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.<br/>
</div>

<div class="doc">
If you want to test your skills, it would be good practice to write
three different versions of "tl", just like I did for "hd", and prove
them correct.
<pre>
Definition tl_error (A : Type) (l : list A)
  : option list A
:=
  ...
Definition tl_never_fail (A : Type) (lst : list A) (safety_proof : lst &lt;&gt; nil)
  : list A
:=
  ...
</pre>

<div class="paragraph"> </div>

Here's just a simple proof that the "hd" and "tl" of a non-empty list
can be used to reconstruct the list.

</div>
<div class="code">
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">hd_tl</span> :<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span>:<span class="id" title="keyword">Type</span>,<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">forall</span> (<span class="id" title="var">default</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">x</span> : <span class="id" title="var">A</span>) (<span class="id" title="var">lst</span> : <span class="id" title="var">list</span> <span class="id" title="var">A</span>),<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="var">hd</span> <span class="id" title="var">A</span> <span class="id" title="var">default</span> (<span class="id" title="var">x</span>::<span class="id" title="var">lst</span>)) :: (<span class="id" title="var">tl</span> <span class="id" title="var">A</span> (<span class="id" title="var">x</span>::<span class="id" title="var">lst</span>)) = (<span class="id" title="var">x</span> :: <span class="id" title="var">lst</span>))).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">A</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">intros</span> <span class="id" title="var">default</span> <span class="id" title="var">x</span> <span class="id" title="var">lst</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">simpl</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">exact</span> (<span class="id" title="var">eq_refl</span> (<span class="id" title="var">x</span>::<span class="id" title="var">lst</span>)).<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab57"></a><h3 class="section">Appending lists</h3>

<div class="paragraph"> </div>

We often want to do more than just add one element at the front of a
list.  Coq includes the function "app", short for "append", to
concatenate two lists.

<div class="paragraph"> </div>

<pre>
Definition app (A : Type) : list A -&gt; list A -&gt; list A :=
  fix app l m :=
  match l with
   | nil =&gt; m
   | a :: l1 =&gt; a :: app l1 m
  end.

Infix "++" := app (right associativity, at level 60) : list_scope.
</pre>

<div class="paragraph"> </div>

Here are some nice theorems you can try to prove about appending lists.
Since append is defined recursively, many of these theorems must be
proved with induction using the "elim" tactic.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_nil_l</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span>:<span class="id" title="keyword">Type</span>, (<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span>:<span class="id" title="var">list</span> <span class="id" title="var">A</span>, <span class="id" title="var">nil</span> ++ <span class="id" title="var">l</span> = <span class="id" title="var">l</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">admit</span>. </div>

<div class="doc">
delete "admit" and put your proof here. 
</div>
<div class="code">
<span class="id" title="var">Admitted</span>. </div>

<div class="doc">
when done, replace "Admitted." with "Qed." 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_nil_r</span> : (<span class="id" title="keyword">forall</span> <span class="id" title="var">A</span>:<span class="id" title="keyword">Type</span>, (<span class="id" title="keyword">forall</span> <span class="id" title="var">l</span>:<span class="id" title="var">list</span> <span class="id" title="var">A</span>, <span class="id" title="keyword">forall</span> <span class="id" title="var">l</span>:<span class="id" title="var">list</span> <span class="id" title="var">A</span>, <span class="id" title="var">l</span> ++ <span class="id" title="var">nil</span> = <span class="id" title="var">l</span>)).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">admit</span>. </div>

<div class="doc">
delete "admit" and put your proof here. 
</div>
<div class="code">
<span class="id" title="var">Admitted</span>. </div>

<div class="doc">
when done, replace "Admitted." with "Qed." 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_comm_cons</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span>:<span class="id" title="var">list</span> <span class="id" title="var">A</span>) (<span class="id" title="var">a</span>:<span class="id" title="var">A</span>), <span class="id" title="var">a</span> :: (<span class="id" title="var">x</span> ++ <span class="id" title="var">y</span>) = (<span class="id" title="var">a</span> :: <span class="id" title="var">x</span>) ++ <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">admit</span>. </div>

<div class="doc">
delete "admit" and put your proof here. 
</div>
<div class="code">
<span class="id" title="var">Admitted</span>. </div>

<div class="doc">
when done, replace "Admitted." with "Qed." 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_assoc</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> (<span class="id" title="var">l</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>:<span class="id" title="var">list</span> <span class="id" title="var">A</span>), <span class="id" title="var">l</span> ++ <span class="id" title="var">m</span> ++ <span class="id" title="var">n</span> = (<span class="id" title="var">l</span> ++ <span class="id" title="var">m</span>) ++ <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">admit</span>. </div>

<div class="doc">
delete "admit" and put your proof here. 
</div>
<div class="code">
<span class="id" title="var">Admitted</span>. </div>

<div class="doc">
when done, replace "Admitted." with "Qed." 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <span class="id" title="var">app_cons_not_nil</span> : <span class="id" title="keyword">forall</span> <span class="id" title="var">A</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span>:<span class="id" title="var">list</span> <span class="id" title="var">A</span>) (<span class="id" title="var">a</span>:<span class="id" title="var">A</span>), <span class="id" title="var">nil</span> &lt;&gt; <span class="id" title="var">x</span> ++ <span class="id" title="var">a</span> :: <span class="id" title="var">y</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
&nbsp;&nbsp;<span class="id" title="var">admit</span>. </div>

<div class="doc">
delete "admit" and put your proof here. 
</div>
<div class="code">
<span class="id" title="var">Admitted</span>. </div>

<div class="doc">
when done, replace "Admitted." with "Qed." 
<div class="paragraph"> </div>

<a name="lab58"></a><h1 class="section">Conclusion</h1>

<div class="paragraph"> </div>

I designed this tutorial to give you just enough to get started in
Coq.  You know enough concepts to have an idea of how things work in
Coq and how things relate.  You may only know a small number of simple
tactics, but they're powerful enough that you can prove real theorems.

<div class="paragraph"> </div>

As you get more experience, you'll see more complex concepts and use
more tactics.  You may even get to use SSReflect, which is a separate
tactics language!  As you read more Coq proofs, you'll also see
different styles for writing proofs.  (Any expert will tell you that
this tutorial's simple style is strikingly different from that used in
their proofs.)

<div class="paragraph"> </div>

I hope you've seen some of the power and possibilities of Coq.  Many
expert provers consider Coq proofs a puzzle and I wish you luck in
solving your puzzles!

<div class="paragraph"> </div>

<a name="lab59"></a><h1 class="section">Postscripts</h1>

<div class="paragraph"> </div>

<a name="lab60"></a><h2 class="section">Contact</h2>

<div class="paragraph"> </div>

HTML and Coq versions of the tutorial are hosted on the author's professional website.

<div class="paragraph"> </div>

<a href="https://mdnahas.github.io/doc/nahas_tutorial.html">https://mdnahas.github.io/doc/nahas_tutorial.html</a>
<a href="https://mdnahas.github.io/doc/nahas_tutorial.v">https://mdnahas.github.io/doc/nahas_tutorial.v</a>

<div class="paragraph"> </div>

The author, Michael Nahas, can be reached at michael@nahas.com

<div class="paragraph"> </div>

<a name="lab61"></a><h2 class="section">Further Reading</h2>

<div class="paragraph"> </div>

Coq uses a lot of concepts that I didn't explain.  Below are some good
sources on those topic.

<div class="paragraph"> </div>

For learning about proofs, I recommend the Pulitzer Prize winning book
"Godel, Escher, Bach", Chapters 7 and 8.  (Pages 181 to 230 in my
copy.)

<div class="paragraph"> </div>

For learning about some of the ideas used in formal proofs, you can
read about Intuitionistic logic, the Curry-Howard correspondence, and
the BHK-Interpretation.

<div class="paragraph"> </div>

<a href="http://en.wikipedia.org/wiki/Intuitionistic_logic">http://en.wikipedia.org/wiki/Intuitionistic_logic</a>

<div class="paragraph"> </div>

<a href="http://en.wikipedia.org/wiki/Curry-Howard_correspondence">http://en.wikipedia.org/wiki/Curry-Howard_correspondence</a>

<div class="paragraph"> </div>

<a href="http://en.wikipedia.org/wiki/BHK_interpretation">http://en.wikipedia.org/wiki/BHK_interpretation</a>

<div class="paragraph"> </div>

If you have a deep interest in logic, I highly recommend Gentzen's
"Investigations into Logical Deductions".  It's not necessary at all,
but it is a beautiful paper.

<div class="paragraph"> </div>

If you need to learn a programming language, OCaml is the one that
would help you with Coq the most.  Coq is written in OCaml and it
borrows a lot of OCaml's syntax and style.

<div class="paragraph"> </div>

<a href="https://ocaml.org">https://ocaml.org</a>

<div class="paragraph"> </div>

To learn more about Coq, I found the textbook "Software Foundations"
readable.  It focuses on proving programs correct.  You can also look
at Coq's documentation webpage.

<div class="paragraph"> </div>

<a href="https://softwarefoundations.cis.upenn.edu/">https://softwarefoundations.cis.upenn.edu/</a>

<div class="paragraph"> </div>

<a href="https://coq.inria.fr/documentation">https://coq.inria.fr/documentation</a>

<div class="paragraph"> </div>

<a name="lab62"></a><h2 class="section">Vernacular commands</h2>

<div class="paragraph"> </div>

<ul class="doclist">
<li> "Theorem" starts a proof.

</li>
<li> "Qed" ends a proof.

</li>
<li> "Admitted" ends an incomplete proof.

</li>
<li> "Definition" declares a function.

</li>
<li> "Fixpoint" declares a recursive function.

</li>
<li> "Inductive" declares data types.

</li>
<li> "Notation" creates new operators.

</li>
<li> "Infix" also creates new operators.

</li>
<li> "Show Proof" prints out the current state of the proof.

</li>
<li> "Require Import" reads in definitions from a file.

</li>
<li> "Check" prints out a description of a type.

</li>
<li> "Compute" prints out the result of a function call.

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab63"></a><h2 class="section">The tactic guide</h2>

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<i>RULE</i>: If the subgoal starts with "(forall &lt;name&gt; : &lt;type&gt;, ..."
      Then use tactic "intros &lt;name&gt;.".

<div class="paragraph"> </div>

<i>RULE</i>: If the subgoal starts with "&lt;type&gt; -&gt; ..."
      Then use tactic "intros &lt;name&gt;.".

<div class="paragraph"> </div>

<i>RULE</i>: If the subgoal matches an hypothesis,
      Then use tactic "exact &lt;hyp_name&gt;.".

<div class="paragraph"> </div>

<i>RULE</i>: If you have an hypothesis
          "&lt;hyp_name&gt;: &lt;type1&gt; -&gt; &lt;type2&gt; -&gt; ... -&gt; &lt;result_type&gt;"
     OR an hypothesis
            "&lt;hyp_name&gt;: (forall &lt;obj1&gt;:&lt;type1&gt;, (forall &lt;obj2&gt;:&lt;type2&gt;, ... &lt;result_type&gt; ...))"
     OR any combination of "-&gt;" and "forall",
     AND you have hypotheses of type "type1", "type2"...,
     Then use tactic "pose" to create something of type "result_type".

<div class="paragraph"> </div>

<i>RULE</i>: If you have subgoal "&lt;goal_type&gt;"
     AND have hypothesis
          "&lt;hyp_name&gt;: &lt;type1&gt; -&gt; &lt;type2&gt; -&gt; ... -&gt; &lt;typeN&gt; -&gt; &lt;goal_type&gt;",
     Then use tactic "refine (&lt;hyp_name&gt; _  ...)." with N underscores.

<div class="paragraph"> </div>

<i>RULE</i>: If your subgoal is "True",
     Then use tactic "exact I.".

<div class="paragraph"> </div>

<i>RULE</i>: If your subgoal is "~&lt;type&gt;" or "~(&lt;term&gt;)" or "(not &lt;term&gt;)",
     Then use tactic "intros".

<div class="paragraph"> </div>

<i>RULE</i>: If any hypothesis is "&lt;name&gt; : False",
     Then use tactic "case &lt;name&gt;.".

<div class="paragraph"> </div>

<i>RULE</i>: If the current subgoal contains a function call with all its arguments,
     Then use the tactic "simpl.".

<div class="paragraph"> </div>

<i>RULE</i>: If there is a hypothesis "&lt;name&gt;" of a created type
     AND that hypothesis is used in the subgoal,
     Then you can try the tactic "case &lt;name&gt;.".

<div class="paragraph"> </div>

<i>RULE</i>: If the subgoal's top-most term is a created type,
      Then use "refine (&lt;name_of_constructor&gt; _  ...).".

<div class="paragraph"> </div>

<i>RULE</i>: If a hypothesis "&lt;name&gt;" is a created type with only one
constructor,
     Then use "destruct &lt;name&gt; as <span class="inlinecode"></span> <span class="inlinecode">&lt;<span class="id" title="var">arg1</span>&gt;</span> <span class="inlinecode">&lt;<span class="id" title="var">arg2</span>&gt;</span> <span class="inlinecode">...</span> <span class="inlinecode"></span>." to extract its arguments.

<div class="paragraph"> </div>

<i>RULE</i>: If a hypothesis "&lt;name&gt;" contain a function call with all its arguments,
     Then use the tactic "simpl in &lt;name&gt;.".

<div class="paragraph"> </div>

<i>RULE</i>: If you have a subgoal that you want to ignore for a while,
     Then use the tactic "admit.".

<div class="paragraph"> </div>

<i>RULE</i>: If the current subgoal starts "exists &lt;name&gt;, ..."
     Then create a witness and use "refine (ex_intro _ witness _).".

<div class="paragraph"> </div>

<i>RULE</i>: If you have a hypothesis "&lt;name&gt; : &lt;a&gt; = &lt;b&gt;"
     AND "&lt;a&gt;" in your current subgoal
     Then use the tactic "rewrite &lt;name&gt;.".

<div class="paragraph"> </div>

<i>RULE</i>: If you have a hypothesis "&lt;name&gt; : &lt;a&gt; = &lt;b&gt;"
     AND "&lt;b&gt;" in your current subgoal
     Then use the tactic "rewrite &lt;- &lt;name&gt;.".

<div class="paragraph"> </div>

<i>RULE</i>: If you have a hypothesis
          "&lt;name&gt; : (&lt;constructor1&gt; ...) = (&lt;constructor2&gt; ...)
     OR "&lt;name&gt; : &lt;constant1&gt; = &lt;constant2&gt;
     Then use the tactic "discriminate &lt;name&gt;.".

<div class="paragraph"> </div>

<i>RULE</i>: If there is a hypothesis "&lt;name&gt;" of a created type
     AND that hypothesis is used in the subgoal,
     AND the type has a recursive definition
     Then you can try the tactic "elim &lt;name&gt;.".

</div>
<div class="code">
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
</html>
